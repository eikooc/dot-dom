(function(){const pages=[{"idx":0,"href":"/dot-dom/docs/install/getting-started/","title":"Getting Started","content":" Getting Started Welcome to the exciting world of .dom.\nThere are various ways you can experiment or integrate .dom in your use case.\n You can use the on-line playground You can integrate .dom in your website without any external dependencies. You can create a web-app with it using babel and webpack.  Or you can keep reading to learn more about it.\nNext Topic  Website with Declarative DOM \u0026rarr;     "},{"idx":1,"href":"/dot-dom/docs/api/globals/","title":"Globals","content":" Globals When sourced, .dom library exposes a few entry point functions for defining and rendering elements.\n.H - Create Element H( \u0026#39;tag\u0026#39; ) H( \u0026#39;tag\u0026#39;, {prop: \u0026#34;value\u0026#34;}) H( \u0026#39;tag\u0026#39;, H( \u0026#39;child\u0026#39; )) H( \u0026#39;tag\u0026#39;, {prop: \u0026#34;value\u0026#34;}, H( \u0026#39;child\u0026#39; )) H( Component, {prop: \u0026#34;value\u0026#34;} )  Create and return a new VDom element of the given type. The type argument can be either a tag name string (such as \u0026lsquo;div\u0026rsquo; or \u0026lsquo;span\u0026rsquo;) or a Component function.\nIf you are using JSX, your code will be converted to use the H() function. You will not typically invoke H() directly. Refer to the JSX Integration for more details.\nImportant! You should never use the following property names, since it will lead to unexpected behaviour or run-time errors:\n $ - Used to differentiate VNode instances from regular objects c - Reserved internally for keeping the children of a VDom element   Tag Shorthands The exposed .H variable is not a simple function, but rather a multi-functional object.\nAccessing any property under the .H object, will return the same .H function, but with the first argument bound to a tag name same as the property being accessed.\nH.div(\u0026#34;Hello\u0026#34;) // equals H(\u0026#39;div\u0026#39;, \u0026#34;Hello\u0026#34;)  This feature is the foundation of the Declarative DOM Composition. Refer to the guide for more details.\n.R - Render R( VNode, HTMLDomElement ) R( [VNode, ...], HTMLDomElement ) R( \u0026#34;String\u0026#34;, HTMLDomElement )  Renders the given VDom tree as children of the given HTML DOM element. The first argument can either be a single VDom element or an array of VDom elements.\nNote that string is a valid VNode element representing a #text node.\n"},{"idx":2,"href":"/dot-dom/docs/topics/quick-start/","title":"Quick Start","content":" Quick Start The smallest .dom example looks like this:\nUigKICBIKCYjMzQ7cCYjMzQ7LCAmIzM0O0hlbGxvIFdvcmxkJiMzNDspLAogIGRvY3VtZW50LmJvZHkKKTs=    Loading interactive example...   It displays a paragraph, saying \u0026ldquo;Hello World\u0026rdquo; in the page, using the Declarative DOM Composition syntax.\nFeel free to make some changes, and see how they affect the output. Alternatively, you can click the link below to open an online editor:\nTry it in CodePen\nNext Topic  Declarative DOM \u0026rarr;     "},{"idx":3,"href":"/dot-dom/docs/api/component-functions/","title":"Component Functions","content":" Component Functions This page explains in detail the component functions.\nEvery component function is called during the rendering phase of the DOM and it must return a valid VDom element to render. Any code logic that should be called during a particular lifecycle event of the node should be registered via the hooks object.\nfunction Component(props, state, setState, hooks) { return ... }   props : The properties object, as given by the user in the H function state : An object that contains the state values of the object setState : A function that can be used to update the state and re-render the element hooks : An object where you can register the lifecycle method hooks  Note that the state object instance remains untouched throughout the life-cycle of the component. This means that you can use it for keeping local properties without triggering a re-render.  Special Properties There are some properties that the .dom engine uses for a specific uses. You should not use properties with these names in your application, but some of them can be used for their intended purpose.\nk: - Key The k property specifies the indexing key for the VDom element. This key is used during reconciliation, in order to preserve the instance of the DOM element when re-ordering.\nThis is particularly useful when you are rendering an array of items whose order is important. Using a unique key for each item will reduce the number of elements affected during an update and will improve the rendering performance.\nFor more information refer to the Reconciliation section.\nsetState() setState( Object )  The setState function updates the local component state and re-renders it.\nImportant! When in the same handler you call setState and also call a handler function that you received as property, make sure to call setState first and then call-out to the handler.\n// First call setState  setState({ value: newValue }); // And **then** call-out to handlers  if (props.onChange) props.onChange();  That\u0026rsquo;s due to a limitation in the internals of the .dom engine, that could lead into invalid state updates if the parent element updates before the child element!\n The properties given in the object will be shallow-merged with the properties in the state.\nFor example, when given a state:\n{ foo: \u0026#34;foo\u0026#34;, bar: \u0026#34;bar\u0026#34;, deep: { a: 1 } };  Calling:\nsetState({ foo: \u0026#34;bar\u0026#34;, deep: { b: 2 } });  Will produce the following (note the value of deep property):\n{ foo: \u0026#34;bar\u0026#34;, bar: \u0026#34;bar\u0026#34;, deep: { b: 2 } };  hooks{ } { m : [], // Array of didMount() callbacks  u : [], // Array of willUnmount() callbacks  d : [], // Array of didUpdate() callbacks  r : false // Raw Component Indicator }  The hooks object can be used for registering lifecycle callbacks for your component.\n.m - didMount() hooks.m.push( function( domInstance ) { ... } )  The mount callbacks are called when the component has finished mounting itself in the DOM.\nThe first argument given is the instance of the root DOM element.\n.u - didUnmount() hooks.u.push( function( domInstance ) { ... } )  The unmount callbacks are called when the component has finished removing itself from the DOM.\nThe first argument given is the instance of the root DOM element.\n.d - didUpdate() hooks.u.push( function( domInstance ) { ... } )  The update callbacks are called when the component has finished updating it\u0026rsquo;s properties.\nThe first argument given is the instance of the root DOM element.\n.r - Raw Flag hooks.r = \u0026lt;truthy\u0026gt; | \u0026lt;falsy\u0026gt;  The raw flag indicates that this component is \u0026ldquo;raw\u0026rdquo; (eg. manipulates it\u0026rsquo;s own DOM children) and should be opted-out from .dom reconciliation logic.\nYou can set any truthy value to enable this flag (true, 1, \u0026quot;\u0026quot;, {}, [], etc.)\n"},{"idx":4,"href":"/dot-dom/docs/topics/declarative/","title":"Declarative DOM","content":" Declarative DOM Composition The .dom library comes with a built-in accelerators that makes it possible to rapidly design human-readable DOM layouts without the need of JSX, or any other Javascript preprocessor.\nThis is achieved through Proxy methods built on top of the .H (create element) function, creating a native Javascript syntactic sugar:\nZGl2KAogIGRpdi51bmRlcmxpbmUoCiAgICAmIzM0O1dlbGNvbWUhJiMzNDsKICApLAogIHAoCiAgICAmIzM0O0luIHRoaXMgZXhhbXBsZSB3ZSBkZW1vbnN0cmF0ZSAmIzM0OywKICAgICYjMzQ7dGhlICYjMzQ7LCBiKCYjMzQ7LmRvbSYjMzQ7KSwgJiMzNDsgYWNjZWxlcmF0b3JzLiYjMzQ7CiAgKSwKICBwKAogICAgJiMzNDtDcmVhdGUgJiMzNDssIHNwYW4ucmVkKCYjMzQ7cG93ZXJmdWwmIzM0OyksCiAgICAmIzM0OyBsYXlvdXRzIHdpdGggJiMzNDssIGIoJiMzNDtuYXRpdmUgSlMhJiMzNDspCiAgKQop    Loading interactive example...   .tag Accelerators When accessing a property out of the H function, a new function is composed, with the tag argument, bound to a tag named as the property.\nTypically you should use the ES6 destructuring operator in the beginning of your script to create helpers for the HTML entities you are using later. For example:\nconst { div, b, i } = H;  This allows us to compose an HTML document in a natural manner like so:\nZGl2KAogIGRpdigmIzM0O05hbWU6ICYjMzQ7LCBiKCYjMzQ7Sm9obiYjMzQ7KSksCiAgZGl2KCYjMzQ7U3VybmFtZTogJiMzNDssIGkoJiMzNDtEb2UmIzM0OykpCik=    Loading interactive example...   .class Accelerators When further accessing properties in the tag accelerator, a new function is composed that appends the property name in the list of the element\u0026rsquo;s CSS class names.\nThere is no limit on how many classes you can append, you can keep accessing deeper properties, and each time you will be appending a class name:\nZGl2KAogIHAucmVkLnVuZGVybGluZSgmIzM0O0hlbGxvIHdvcmxkISYjMzQ7KSwKICAvLyBZb3UgY2FuIGFsc28gY3JlYXRlIGNsYXNzZXMgYnkgc3RyaW5nCiAgLy8gYXMgeW91IHdvdWxkIG5vcm1hbGx5IGRvIHdpdGggYW55CiAgLy8gamF2YXNjcmlwdCBvYmplY3QgCiAgcFsmIzM5O2dyZWVuJiMzOTtdKCYjMzQ7V2VsY29tZSB0byB0aGUgd29ybGQgJiMzNDssCiAgICBzcGFuWyYjMzk7Ymx1ZSYjMzk7XS51bmRlcmxpbmUoJiMzNDtvZiAuZG9tISYjMzQ7KQogICkKKQ==    Loading interactive example...    Previous Topic  \u0026larr; Quick Start    Next Topic  Components \u0026rarr;     "},{"idx":5,"href":"/dot-dom/docs/install/create-website/","title":"Website with Declarative DOM","content":" Creating a Website with Declarative DOM In the most simple case, you can use .dom as an external library to your website and you can design your layout using the built-in declarative DOM syntax.\nThe .dom library is quite agile and can be used without any external dependencies, such as code transipler (eg babel), packagers (eg. webpack) or other pre-processing tools. In this page we are presenting this simplest use case.\nBoilerplate If you want to start from scratch, you can use the following HTML boilerplate:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;My .dom App\u0026lt;/title\u0026gt; \u0026lt;!-- The .dom library sources --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/wavesoft/dot-dom/dotdom.min.js\u0026#34; integrity=\u0026#34;sha384-iYmnbr5e65SuCt6QZydA\u0026#43;bdS7Lojxq0yNp0S/c68OsYQa8bklHnsBiWC9bE6GhJW\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- The root container where the app will be rendered --\u0026gt; \u0026lt;div id=\u0026#34;main\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- Your App --\u0026gt; \u0026lt;script\u0026gt; // Define some DOM accelerators  const { p } = H; // Define your app entry point component  const App = () =\u0026gt; { return p(\u0026#34;Hello World!\u0026#34;); }; // Render the main app  R(H(App), document.getElementById(\u0026#34;main\u0026#34;)); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Adding to an existing website If you already have a website and you just want to make some parts of it interactive, you can add .dom in three simple steps:\nStep 1 - Add a main view container First you should create an empty element in the place you want .dom to render it\u0026rsquo;s contents:\n\u0026lt;!-- Here is where .dom will render it\u0026#39;s contents --\u0026gt; \u0026lt;div id=\u0026#34;main\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Step 2 - Add script tags Then you should load the .dom library in your website. You can either download it and put it along with the rest of your website assets, or you can use a CDN link:\n\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/wavesoft/dot-dom/dotdom.min.js\u0026#34; integrity=\u0026#34;sha384-iYmnbr5e65SuCt6QZydA\u0026#43;bdS7Lojxq0yNp0S/c68OsYQa8bklHnsBiWC9bE6GhJW\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;/script\u0026gt;  Step 3 - Define your components and render You are now ready to define your components and render your app. You can do this by adding a \u0026lt;script\u0026gt; tag in your body:\n\u0026lt;script\u0026gt; // Define some DOM accelerators  const { p } = H; // Define your app entry point component  const App = () =\u0026gt; { return p(\u0026#34;Hello World!\u0026#34;); }; // Render the main app  R(H(App), document.getElementById(\u0026#34;main\u0026#34;)); \u0026lt;/script\u0026gt;   Previous Topic  \u0026larr; Getting Started    Next Topic  Web-App with JSX \u0026rarr;     "},{"idx":6,"href":"/dot-dom/docs/api/vdom-element/","title":"VDom Element","content":" VDom Element A Virtual DOM (VDom) element is created with the H() method and represents the shadow of a real DOM Element.\nVDom Types A VDom instance can be one of the following types:\n Object - Represents an HTML element, identified by a tag, attributes and children. String - Represents a #text node, that only carries it\u0026rsquo;s contents  Note that the H() function only creates Object VDom instances. String instances can be passed down directly to the engine for rendering.\nFor example, as children:\nconst textNode = \u0026#34;Hello World\u0026#34;; R(H(\u0026#34;div\u0026#34;, textNode), document.body);  Or as immediate nodes:\nconst textNode = \u0026#34;Hello World\u0026#34;; R(textNode, document.body);   Object Properties .$ - Type The .$ property carries the element type. This is either a string that denotes the tag name, or a function of a functional component.\nFor example:\nconst vdom = H(\u0026#34;div\u0026#34;, \u0026#34;Hello World\u0026#34;); console.log(vdom.$); // prints: \u0026#39;div\u0026#39;  .a - Properties The .a object contains the properties passed down to a component. For example:\nconst vdom = H(\u0026#34;div\u0026#34;, {color: \u0026#34;red\u0026#34;}, \u0026#34;Hello World\u0026#34;); console.log(vdom.a); // prints: // { // color: \u0026#34;red\u0026#34;, // c: [ \u0026#34;Hello World\u0026#34; ] // }  Note that the .c property is always implicitly created and it contains the list of the node children of this node.  "},{"idx":7,"href":"/dot-dom/docs/install/create-webapp/","title":"Web-App with JSX","content":" Creating a WebApp with JSX If you want a more descriptive syntax for expressing your components, .dom natively supports React\u0026rsquo;s JSX syntax.\nYou can use the same tooling as with React to pre-process your javascript sources and convert them to .dom function calls. In this page we are describing step-by-step the process you should follow in order to create a single-page application using webpack and babel.\nStarting a node project First we should start by creating a blank new node.js project:\nmkdir my-dotdom-app; cd my-dotdom-app yarn init -y yarn is a faster package manager than npm an we are urging your to give it a try if you haven\u0026rsquo;t done already. However if you still want to use npm, substitute the commands like so:\n yarn init -y \u0026rarr; npm init -y yarn add ... \u0026rarr; npm install --save ... yarn add -D ... \u0026rarr; npm install --save-dev ...   Setting-up Dependencies We are going to use webpack as our main build tool. It is responsible for packaging all of our project assets into bundles, pre-processing them with some filters if needed. Let\u0026rsquo;s add it:\nyarn add -D webpack webpack-cli webpack-dev-server We are going to use babel to pre-process our javascript sources on-the-fly. And more specifically, we are going to use the plugin-transform-react-jsx plugin to convert the JSX notation into standard javascript.\nWe are also going to use the smart preset-env that automatically finds out the correct javascript transformations in order to be compatible with all browser versions.\nyarn add -D babel-loader @babel/core @babel/preset-env @babel/plugin-transform-react-jsx And finally, we should add the dot-dom library:\nyarn add dot-dom Adding boilerplate code Let\u0026rsquo;s continue creating the structure of our project, and more specifically the entry point for our javascript and HTML part in the following locations:\n- src/ -- index.js - dist/ -- index.html  The src/index.js is the entry point to our web app. Create it with following contents:\nimport DotDom from \u0026#39;dot-dom\u0026#39;; DotDom.R( \u0026lt;h1\u0026gt;.dom and JSX\u0026lt;/h1\u0026gt;, document.getElementById(\u0026#39;app\u0026#39;) ); This funny tag syntax is neither a string nor HTML. It is called JSX, and it is a syntax extension to JavaScript proposed by React.  The dist/index.html is the static HTML page that loads our application bundle. Create it with following contents:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Hello .dom\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;./bundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Configuring Webpack For our next step, we should configure webpack. More specifically we must instruct it to pass all the .js sources through the babel-loader plugin, that is going to translate the JSX expressions in our source code.\nCreate a file called webpack.config.js with the following contents:\nmodule.exports = { entry: \u0026#39;./src/index.js\u0026#39;, module: { rules: [ { test: /\\.(js)$/, exclude: /node_modules/, use: [\u0026#39;babel-loader\u0026#39;] } ] }, output: { path: __dirname + \u0026#39;/dist\u0026#39;, publicPath: \u0026#39;/\u0026#39;, filename: \u0026#39;bundle.js\u0026#39; }, devServer: { contentBase: \u0026#39;./dist\u0026#39; } };  The babel plugin is further configured with a separate file. You must then create a file called .babelrc in the root directory of your project with the following contents:\n{ \u0026#34;presets\u0026#34;: [ \u0026#34;@babel/preset-env\u0026#34; ], \u0026#34;plugins\u0026#34;: [ [\u0026#34;@babel/plugin-transform-react-jsx\u0026#34;, { \u0026#34;pragma\u0026#34;: \u0026#34;DotDom.H\u0026#34; }] ] } Adding build scripts It\u0026rsquo;s a good practice to add the following build scripts in your package.json:\n... \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;webpack --mode production\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;webpack-dev-server --mode development\u0026#34; }, ... This will allow you to build your project by simply running yarn build, or start a development server by running yarn start.\nTrying it out You are now ready to start the webpack development server and see your project.\nyarn start You can now open http://127.0.0.1:8080 and see your app.\n Previous Topic  \u0026larr; Website with Declarative DOM    Next Topic  Serving GZ version of .dom \u0026rarr;     "},{"idx":8,"href":"/dot-dom/docs/topics/components/","title":"Components","content":" Components Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.\nConceptually, components are like JavaScript functions. They accept arbitrary inputs (called \u0026ldquo;props\u0026rdquo;) and return Virtual DOM elements describing what should appear on the screen.\nComponent Functions All components in .dom are Javascript functions:\nconst { div } = H; function Welcome(props) { return div(`Hello ${props.name}`); }  This function is a valid .dom component because it accepts a \u0026ldquo;props\u0026rdquo; object argument and returns a Virtual DOM element.\nRendering Components We have previously seen that you can render HTML elements using the H function:\nconst elm = H(\u0026#34;div\u0026#34;, \u0026#34;Hello world\u0026#34;);  You can use the same function to render components.\nconst elm = H(Welcome, {\u0026#34;name\u0026#34;: \u0026#34;World\u0026#34;});  Note that you cannot use the deconstructuring accelerator with Components. You must always call H(Component) to render it.  The library will call-out to your component, passing down the props given and will collect the resulting VDom tree.\nYou can see this in action:\nY29uc3QgeyBkaXYgfSA9IEg7CgovLyBEZWZpbmUgdGhlIGNvbXBvbmVudApmdW5jdGlvbiBXZWxjb21lKHByb3BzKSB7CiAgcmV0dXJuIGRpdihgSGVsbG8gJHtwcm9wcy5uYW1lfWApOwp9CgovLyBSZW5kZXIgaXQgClIoCiAgSChXZWxjb21lLCB7JiMzNDtuYW1lJiMzNDs6ICYjMzQ7V29ybGQmIzM0O30pLCAKICBkb2N1bWVudC5ib2R5Cik7    Loading interactive example...   Composing Components Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in a .dom app, all those are commonly expressed as components.\nY29uc3QgeyBkaXYgfSA9IEg7CgovLyBEZWZpbmUgdGhlIGNvbXBvbmVudApmdW5jdGlvbiBXZWxjb21lKHByb3BzKSB7CiAgcmV0dXJuIGRpdihgSGVsbG8gJHtwcm9wcy5uYW1lfWApOwp9CgovLyBEZWZpbmUgdGhlIGFwcApmdW5jdGlvbiBBcHAocHJvcHMpIHsKICByZXR1cm4gZGl2KAogICAgSChXZWxjb21lLCB7bmFtZTogJiMzNDtBbGljZSYjMzQ7fSksCiAgICBIKFdlbGNvbWUsIHtuYW1lOiAmIzM0O0JvYiYjMzQ7fSksCiAgICBIKFdlbGNvbWUsIHtuYW1lOiAmIzM0O0NoYXJsaW5lJiMzNDt9KQogICk7Cn0KCi8vIFJlbmRlciB0aGUgYXBwClIoCiAgSChBcHApLAogIGRvY3VtZW50LmJvZHkKKTs=    Loading interactive example...    Previous Topic  \u0026larr; Declarative DOM    Next Topic  Stateful Components \u0026rarr;     "},{"idx":9,"href":"/dot-dom/docs/topics/stateful-components/","title":"Stateful Components","content":" Stateful Components Components can only carry properties given, but can also maintain their own state.\nFor example, consider the case of a spinner widget, where the user has two buttons : one to increment the value and one to decrement, like so:\nY29uc3QgeyBkaXYsIGJ1dHRvbiB9ID0gSDsKCmZ1bmN0aW9uIFNwaW5uZXIocHJvcHMpIHsKICByZXR1cm4gZGl2LnJvd2ZsZXgoCiAgICBidXR0b24oJiMzNDstJiMzNDspLAogICAgZGl2KGAke3Byb3BzLnZhbHVlfWApLAogICAgYnV0dG9uKCYjMzQ7KyYjMzQ7KQogICk7Cn0KClIoSChTcGlubmVyLCB7dmFsdWU6IDB9KSwgZG9jdW1lbnQuYm9keSk7    Loading interactive example...   But what should happen when the user clicks the \u0026ldquo;+\u0026rdquo; or the \u0026ldquo;-\u0026rdquo; button? To answer this question we will introduce you to the Component State\nComponent State Every component is created with an empty state object, initialized to { }. This object persists throughout the life-cycle of the component and is disposed when unmounted.\nThe component can update it\u0026rsquo;s state by calling the setState method, giving the new values for the state properties. This will cause the element to re-render in order to apply the new values.\nThe state and setState variables are passed as arguments to the component function, right after the props object:\nfunction Welcome(props, state, setState) { // ... }  This means that we can now re-write our spinner widget using the state object like so:\nY29uc3QgeyBkaXYsIGJ1dHRvbiB9ID0gSDsKCmZ1bmN0aW9uIFNwaW5uZXIoCiAgcHJvcHMsIAogIHt2YWx1ZT1wcm9wcy52YWx1ZX0sIAogIHNldFN0YXRlCikgewogIHJldHVybiBkaXYucm93ZmxleCgKICAgIC8vIERlY3JlbWVudCBidXR0b24KICAgIGJ1dHRvbih7CiAgICAgIG9uY2xpY2soKSB7CiAgICAgICAgc2V0U3RhdGUoeyB2YWx1ZTogdmFsdWUgLSAxIH0pCiAgICAgIH0KICAgIH0sICYjMzQ7LSYjMzQ7KSwKICAgIC8vIFZhbHVlIGxhYmVsCiAgICBkaXYoYCR7dmFsdWV9YCksCiAgICAvLyBJbmNyZW1lbnQgYnV0dG9uCiAgICBidXR0b24oewogICAgICBvbmNsaWNrKCkgewogICAgICAgIHNldFN0YXRlKHsgdmFsdWU6IHZhbHVlICsgMSB9KQogICAgICB9CiAgICB9LCAmIzM0OysmIzM0OykKICApOwp9CgpSKEgoU3Bpbm5lciwge3ZhbHVlOiAwfSksIGRvY3VtZW50LmJvZHkpOw==    Loading interactive example...   State Propagation When designing stateful components, it\u0026rsquo;s important to find out where the state of your application will be. It is a good practice to keep the state to the top-most component and pass down portions of it, to stateless components.\nAs an exception of this rule, it is also acceptable to use stateful components that maintain a temporary state of a user-interfacing component.\nExample Consider the more complicated example of a ToDo List App. In this example, we are using three kinds of components:\n The TodoList component that renders the items and the input field The TodoItem component that renders a single item and allows the user to mark it as completed. The InputField where the user enters the new item text  In such cases it\u0026rsquo;s important to find out where the state is going to be maintained. It is typically a good practice to keep the state to the root component and pass down portions of it to stateless components.\nLet\u0026rsquo;s start designing our leaf components. First the TodoItem component:\nfunction TodoItem({ text, completed, oncomplete }) { return div.rowflex( button( { onclick: oncomplete}, \u0026#34;Ok\u0026#34; ), div[completed ? \u0026#34;strike\u0026#34; : \u0026#34;\u0026#34;](text) ); }  This stateless component accepts the following properties:\n text : The text of the eleemtn completed : A boolean flag that indicates if the item is completed oncomplete : A callback function to call when the user completes the item  Then let\u0026rsquo;s design the InputField component:\nfunction InputField({ oncreate }, {text=\u0026#34;\u0026#34;}, setState) { return div.rowflex( input({ type: \u0026#39;text\u0026#39;, value: text, onchange(e) { setState({ text: e.target.value }) } }), button({ onclick() { setState({ text: \u0026#34;\u0026#34; }); oncreate(text); } }, \u0026#34;Create\u0026#34;) ) }  Important! When in the same handler you call setState and also call a handler function that you received as property, make sure to call setState first and then call-out to the handler.  This is a stateful component, that uses it\u0026rsquo;s local state only for keeping track of the user input. It still forwards the important events to the parent.\nIt accepts the following properties:\n oncreate : A callback function that will be called when the user clicks the \u0026ldquo;Create\u0026rdquo; button, passing down the value the user has entered.  And finally, let\u0026rsquo;s design the TodoList component:\nfunction TodoList(props, {items=[]}, setState) { const addItem = text =\u0026gt; { setState({ items: items.concat({ text, completed: false }) }) }; const checkItem = index =\u0026gt; { items[index].completed = !items[index].completed; setState({ items }); }; return div( items.map((item, index) =\u0026gt; H(TodoItem, { text: item.text, completed: item.completed, oncomplete: checkItem.bind(index) })), H(InputField, { oncreate: addItem }) ); }  And here is what the full example looks like:\nY29uc3QgeyBkaXYsIGJ1dHRvbiwgaW5wdXQgfSA9IEg7CgpmdW5jdGlvbiBUb2RvSXRlbSh7IHRleHQsIGNvbXBsZXRlZCwgb25jb21wbGV0ZSB9KSB7CiAgcmV0dXJuIGRpdi5yb3dmbGV4KAogICAgYnV0dG9uKAogICAgICB7IG9uY2xpY2s6IG9uY29tcGxldGV9LCAKICAgICAgJiMzNDtPayYjMzQ7CiAgICApLAogICAgZGl2W2NvbXBsZXRlZCA/ICYjMzQ7c3RyaWtlJiMzNDsgOiAmIzM0OyYjMzQ7XSh0ZXh0KQogICk7Cn0KCmZ1bmN0aW9uIElucHV0RmllbGQoeyBvbmNyZWF0ZSB9LCB7dGV4dD0mIzM0OyYjMzQ7fSwgc2V0U3RhdGUpIHsKICByZXR1cm4gZGl2LnJvd2ZsZXgoCiAgICBpbnB1dCh7CiAgICAgIHR5cGU6ICYjMzk7dGV4dCYjMzk7LAogICAgICB2YWx1ZTogdGV4dCwKICAgICAgb25jaGFuZ2UoZSkgewogICAgICAgIHNldFN0YXRlKHsgdGV4dDogZS50YXJnZXQudmFsdWUgfSkKICAgICAgfQogICAgfSksCiAgICBidXR0b24oewogICAgICBvbmNsaWNrKCkgewogICAgICAgIHNldFN0YXRlKHsgdGV4dDogJiMzNDsmIzM0OyB9KTsKICAgICAgICBvbmNyZWF0ZSh0ZXh0KTsKICAgICAgfQogICAgfSwgJiMzNDtDcmVhdGUmIzM0OykKICApCn0KCmZ1bmN0aW9uIFRvZG9MaXN0KHByb3BzLCBzdGF0ZSwgc2V0U3RhdGUpIHsKICBjb25zdCBhZGRJdGVtID0gdGV4dCA9Jmd0OyB7CiAgICBzZXRTdGF0ZSh7CiAgICAgIGl0ZW1zOiBbXS5jb25jYXQoewogICAgICAgIHRleHQsCiAgICAgICAgY29tcGxldGVkOiBmYWxzZQogICAgICB9LCAoc3RhdGUuaXRlbXMgfHwgW10pKQogICAgfSkKICB9OwogIGNvbnN0IGNoZWNrSXRlbSA9IGluZGV4ID0mZ3Q7IHsKICAgIHN0YXRlLml0ZW1zW2luZGV4XS5jb21wbGV0ZWQgPSAKICAgICAgIXN0YXRlLml0ZW1zW2luZGV4XS5jb21wbGV0ZWQ7CiAgICBzZXRTdGF0ZSh7IH0pOwogIH07CgogIHJldHVybiBkaXYoCiAgICBIKElucHV0RmllbGQsIHsgb25jcmVhdGU6IGFkZEl0ZW0gfSksCiAgICAoc3RhdGUuaXRlbXMgfHwgW10pLm1hcCgoaXRlbSwgaW5kZXgpID0mZ3Q7IEgoVG9kb0l0ZW0sIHsKICAgICAgazogaXRlbS50ZXh0LAogICAgICB0ZXh0OiBpdGVtLnRleHQsCiAgICAgIGNvbXBsZXRlZDogaXRlbS5jb21wbGV0ZWQsCiAgICAgIG9uY29tcGxldGU6IGNoZWNrSXRlbS5iaW5kKHRoaXMsIGluZGV4KQogICAgfSkpLAogICk7Cn0KClIoSChUb2RvTGlzdCksIGRvY3VtZW50LmJvZHkpOw==    Loading interactive example...    Previous Topic  \u0026larr; Components    Next Topic  Component Lifecycle \u0026rarr;     "},{"idx":10,"href":"/dot-dom/docs/topics/component-lifecycle/","title":"Component Lifecycle","content":" Component Lifecycle Every .dom component undergoes through a three phases during it\u0026rsquo;s life-cycle : Mounted, Updated and Unmounted\nAs a developer, you can react to these life-cycle events in order to implement your logic.\nComponent Hooks You can register callback handlers to either of the three life-cycle events through the hooks object, that is given as a 4th argument to the Component function:\nfunction Component(props, state, setState, hooks) { // ... }  You can read more on the Component Functions API reference.\nMounting When a component is created (using the H) function, the newly created instance does not yet have a DOM reflection.\nWhen rendered, and the VDom element obtains a DOM reflection, the VNode is considered to be Mounted.\nAt this point, the .m (didMount) callback is fired. To subscribe for such events, push your handler in the .m array in the hooks object:\nfunction Component(props, state, setState, hooks) { hooks.m.push(function(domElement) { // Do something with the DOM element  }); }  In this handler you can initialize other libraries that are bound to this element. For instance ACE editor, or other WYSIWYG visual editors.  Unmounting When a component is about to be removed from DOM, the node is considered to be Unmounted. At this point, the .u (willUnmount) callback is fired. To subscribe for such events, push your handler in the .u array in the hooks object:\nfunction Component(props, state, setState, hooks) { hooks.u.push(function(domElement) { // Do something with the DOM element  }); }  Updating When a component has finished updating it\u0026rsquo;s properties, it fires the d (didUpdate) callbacks. To subscribe for such events, push your handler in the .d array in the hooks object:\nfunction Component(props, state, setState, hooks) { hooks.d.push(function(domElement) { // Do something with the DOM element  }); }   Previous Topic  \u0026larr; Stateful Components    Next Topic  Raw Components \u0026rarr;     "},{"idx":11,"href":"/dot-dom/docs/topics/raw/","title":"Raw Components","content":" Raw Components If you are controlling the created HTML DOM instance yourself, you can mark the node as raw to disable deeper reconciliation.\nBy default, on every update, .dom will reconcile the children of each VNode instance. This will destroy any previous modifications to the DOM. To disable this functionality, set hooks.r to a truthy value (eg. 1 or true):\nconst RawComponent = (props, state, setState, hooks) =\u0026gt; { // Mark the component as raw  hooks.r = 1; }  HTML Component One use of the raw components is to render plain HTML strings. For example:\nZnVuY3Rpb24gUmVuZGVySFRNTCh7aHRtbH0sIHN0YXRlLCBzZXRTdGF0ZSwgaG9va3MpIHsKICBob29rcy5yID0gdHJ1ZTsKICByZXR1cm4gSCgmIzM0O2RpdiYjMzQ7LCB7CiAgICBpbm5lckhUTUw6IGh0bWwKICB9KQp9CgpSKAogIEgoUmVuZGVySFRNTCwgewogICAgaHRtbDogJiMzNDsmbHQ7cCZndDtIZWxsbyAmbHQ7YiZndDtXb3JsZCZsdDsvYiZndDsmbHQ7L3AmZ3Q7JiMzNDsgCiAgfSksCiAgZG9jdW1lbnQuYm9keQop    Loading interactive example...    Previous Topic  \u0026larr; Component Lifecycle    Next Topic  Reconciliation \u0026rarr;     "},{"idx":12,"href":"/dot-dom/docs/install/","title":"Installation","content":""},{"idx":13,"href":"/dot-dom/docs/topics/reconciliation/","title":"Reconciliation","content":" Reconciliation Because of it\u0026rsquo;s declarative nature, .dom knows which elements to update on a reconciliation events, so there is no requirement by the developer to explicitly control this process.\nIn this document we are describing the details of the reconciliation process of the library, since there are some specific cases where the developer should pay attention. Especially when designing performance-critical interfaces.\nReconciliation in .dom First and foremost is important to clarify that .dom is optimized for size and not for performance. This means that instead of following particular algorithmic \u0026ldquo;best practices\u0026rdquo; we are using quirks and intentional code repetitions that helps compression algorithms produce a smaller result.  When \u0026ldquo;diffing\u0026rdquo; the VDom (in-memory Virtual DOM) with the DOM (the actual page DOM) trees, .dom compares the children of a DOM element with an array of VDom elements.\nFor each element, the operation that takes place depends on the type of the two elements encountered.\nElements Of Different Types When the diffing algorithm encounters two elements of different types, it tears down the old tree and creates a new tree from scratch.\nThis includes switching from one tag to another (eg. \u0026lt;span\u0026gt; to \u0026lt;div\u0026gt;), switching form one component to another (eg. \u0026lt;Head\u0026gt; to \u0026lt;Banner\u0026gt;) or switching from a tag to a component or vice versa (eg. \u0026lt;div\u0026gt; to \u0026lt;Content\u0026gt;).\nNote that the state of a component is bound to it\u0026rsquo;s root element. This means that if it\u0026rsquo;s parent element is removed and re-created, the component state will also be lost. For example:\n\u0026lt;div\u0026gt; \u0026lt;Counter /\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;span\u0026gt; \u0026lt;Counter /\u0026gt; \u0026lt;/span\u0026gt; Elements Of Same Types When the diffing algorithm encounters two elements of the same type, it updates the DOM element properties with the VDom element properties that have changed.\nIf the DOM element is a root of a component, it\u0026rsquo;s update (.u) callback will be triggered.\nRecursing On Children By default, when recursing on the children of a DOM node, .dom just iterates over both lists of children at the same time and generates a mutation whenever there’s a difference.\nFor example, when adding an element at the end of the children, converting between these two trees works well:\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;first\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;second\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;first\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;second\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;third\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; The diffing algorithm will match the two \u0026lt;li\u0026gt;first\u0026lt;/li\u0026gt; trees, match the two \u0026lt;li\u0026gt;second\u0026lt;/li\u0026gt; trees, and then insert the \u0026lt;li\u0026gt;third\u0026lt;/li\u0026gt; tree.\nIf you implement it naively, inserting an element at the beginning has worse performance. For example, converting between these two trees works poorly:\n\u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Foo\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Bar\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; \u0026lt;ul\u0026gt; \u0026lt;li\u0026gt;Baz\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Foo\u0026lt;/li\u0026gt; \u0026lt;li\u0026gt;Bar\u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; This will mutate every child instead of realizing it can keep the \u0026lt;li\u0026gt;Foo\u0026lt;/li\u0026gt; and \u0026lt;li\u0026gt;Bar\u0026lt;/li\u0026gt; subtrees intact. This inefficiency can be a problem.\nKeys In order to solve this issue, .dom supports a key attribute. When children have keys, .dom uses the key to match children in the original tree with children in the subsequent tree. For example, adding a key to our inefficient example above can make the tree conversion efficient:\nul( li({k: \u0026#34;2015\u0026#34;}, \u0026#34;Foo\u0026#34;), li({k: \u0026#34;2016\u0026#34;}, \u0026#34;Bar\u0026#34;) ) ul( li({k: \u0026#34;2014\u0026#34;}, \u0026#34;Baz\u0026#34;), li({k: \u0026#34;2015\u0026#34;}, \u0026#34;Foo\u0026#34;), li({k: \u0026#34;2016\u0026#34;}, \u0026#34;Bar\u0026#34;), )  Now .dom knows that the element with key '2014' is the new one, and the elements with the keys '2015' and '2016' have just moved.\nIn practice, finding a key is usually not hard. The element you are going to display may already have a unique ID, so the key can just come from your data:\n\u0026lt;li key={item.id}\u0026gt;{item.name}\u0026lt;/li\u0026gt; When that’s not the case, you can add a new ID property to your model or hash some parts of the content to generate a key. The key only has to be unique among its siblings, not globally unique.\nAs a last resort, you can pass an item’s index in the array as a key. This can work well if the items are never reordered, but reorders will be slow.\n Previous Topic  \u0026larr; Raw Components    Next Topic  Gotchas \u0026rarr;     "},{"idx":14,"href":"/dot-dom/docs/install/serving-compressed/","title":"Serving GZ version of .dom","content":" Serving the compressed version of .dom If you want to serve .dom on it\u0026rsquo;s smallest possible size, you might want to serve it compressed.\nFor example, in embedded (eg. IoT) projects the device memory is quite limited. Therefore storing the uncompressed version of the library might not be desired. In such cases, you can always serve .dom directly on it\u0026rsquo;s compressed form.\nThis is achieved simply by setting the correct encoding response header while streaming the compressed library to the client:\nContent-Encoding: gzip  According to HTML standards you should always check the Accept-Encoding request header, and proceed with sending the compressed version of the library only if supported.\nHowever all the browsers in the market natively support the gzip encoding, making this a safe assumption.\n ESP32 Example If you are writing a firmware for an ESP32 chip, you can directly serve the compressed version of the library, following this guide.\nFirst, convert the compressed version of the library into a C array:\ncat dotdom.min.gz | xxd -i \u0026gt;\u0026gt; dot-dom.h Edit dot-dom.h, making sure the bytes are correctly wrapped in a static C array:\nstatic const uint8_t DOT_DOM_JS[] = { // xxd output ...  0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x13, 0x5d, 0x52, ... // ... up to here };  Then, in your HTTP handler just make sure to set the correct headers:\nstatic esp_err_t handle_get_dot_dom(httpd_req_t *req) { httpd_resp_set_hdr(req, \u0026#34;Content-Encoding\u0026#34;, \u0026#34;gzip\u0026#34;); httpd_resp_set_type(req, \u0026#34;application/javascript\u0026#34;); httpd_resp_send(req, DOT_DOM_JS, sizeof(DOT_DOM_JS)); return ESP_OK; }   Previous Topic  \u0026larr; Web-App with JSX     "},{"idx":15,"href":"/dot-dom/docs/topics/","title":"Topics","content":""},{"idx":16,"href":"/dot-dom/docs/api/","title":"API Reference","content":""},{"idx":17,"href":"/dot-dom/docs/topics/gotchas/","title":"Gotchas","content":" Gotchas Since .dom is optimized for size and not for performance nor developer friendliness, you should be aware that there are few rough edges.\nComponent roots cannot change The component state is preserved on it\u0026rsquo;s root DOM element. On it\u0026rsquo;s own turn, this element is indexed by the component\u0026rsquo;s key.\nThis means, that once mounted, the component won\u0026rsquo;t be able to change the type of the root element, since it will be persisted in the cache.\nFor example:\nY29uc3QgeyBkaXYsIGEgfSA9IEg7CgpmdW5jdGlvbiBDb21wb25lbnQocHJvcHMsIHN0YXRlLCBzZXRTdGF0ZSwgbWV0YSkgewogIGNvbnN0IHJvb3QgPSBzdGF0ZS50b2dnbGUgPyAmIzM0O2VtJiMzNDsgOiAmIzM0O3N0cm9uZyYjMzQ7OwoKICByZXR1cm4gSChyb290LCAKICAgIGEoewogICAgICBocmVmOiAmIzM0O2phdmFzY3JpcHQ6OyYjMzQ7LAogICAgICBvbmNsaWNrKCkgewogICAgICAgIHNldFN0YXRlKHsKICAgICAgICAgIHRvZ2dsZTogIXN0YXRlLnRvZ2dsZQogICAgICAgIH0pCiAgICAgIH0KICAgIH0sIAogICAgc3RhdGUudG9nZ2xlCiAgICAgID8gJiMzNDtTd2l0Y2ggdG8gJmx0O3N0cm9uZyZndDsmIzM0OwogICAgICA6ICYjMzQ7U3dpdGNoIHRvICZsdDtlbSZndDsmIzM0OwogICAgKQogICkKfQoKUigKICBkaXYoCiAgICAmIzM0O1RoZSBjb21wb25lbnQgcm9vdCB3aWxsIGFsd2F5cyBiZSAmbHQ7c3Ryb25nJmd0OyAodXNlIGluc3BlY3QgdG8gdmVyaWZ5KTomIzM0OywKICAgIGRpdigKICAgICAgSChDb21wb25lbnQpCiAgICApCiAgKSwKICBkb2N1bWVudC5ib2R5Cik7    Loading interactive example...   First setState locally, then propagate When in the same handler you call setState and also call a handler function that you received as property, make sure to call setState first and then call-out to the handler.\n// First call setState  setState({ value: newValue }); // And **then** call-out to handlers  if (props.onChange) props.onChange();  That\u0026rsquo;s due to a limitation in the internals of the .dom engine, that could lead into invalid state updates if the parent element updates before the child element!\n Previous Topic  \u0026larr; Reconciliation     "},{"idx":18,"href":"/dot-dom/","title":"","content":".dom The tiniest (512 B) VirtualDOM library for creating User Interfaces\n      The .dom (\u0026ldquo;dot dom\u0026rdquo;) is the worlds smallest, most feature-packed Virtual DOM template library. This makes it ideal for embedded UIs, browser extensions, or wherever saving a single byte actually matters!\nIn just 512 bytes (compressed) it provides:\n Virtual DOM reconciliation Declarative composition using native js accelerators Stateful Components, including higher-order component composition Component Life-Cycle methods (mount, unmount, update) Keyed Updates and high-performance optimization JSX integration compatibility  "},{"idx":19,"href":"/dot-dom/categories/","title":"Categories","content":""},{"idx":20,"href":"/dot-dom/docs/","title":"Docs","content":""},{"idx":21,"href":"/dot-dom/tags/","title":"Tags","content":""}];window.bookSearch={pages:pages,idx:lunr(function(){this.ref("idx");this.field("title");this.field("content");pages.forEach(this.add,this);}),}})();