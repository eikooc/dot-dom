<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta property="og:title" content="Reconciliation"><meta property="og:description" content="Reconciliation Because of it&rsquo;s declarative nature, .dom knows which elements to update on a reconciliation events, so there is no requirement by the developer to explicitly control this process.
In this document we are describing the details of the reconciliation process of the library, since there are some specific cases where the developer should pay attention. Especially when designing performance-critical interfaces.
Reconciliation in .dom First and foremost is important to clarify that ."><meta property="og:type" content="article"><meta property="og:url" content="https://wavesoft.github.io/dot-dom/docs/topics/reconciliation/"><title>Reconciliation | .dom Documentation</title><link rel=icon href=/dot-dom/favicon.png type=image/x-icon><link rel=stylesheet href=/dot-dom/book.min.1b994bd28c6ce2255f069b6bf6837b4d396307637fc48d61dcb2a6caac26e031.css integrity="sha256-G5lL0oxs4iVfBptr9oN7TTljB2N/xI1h3LKmyqwm4DE="><script defer src=/dot-dom/search.min.4813f1155ce5fe97e967fcfc91df6348352ce6efea934c3ef9d641de0a0c895b.js integrity="sha256-SBPxFVzl/pfpZ/z8kd9jSDUs5u/qk0w&#43;&#43;dZB3goMiVs="></script><script src=https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.6/ace.js integrity="sha256-CVkji/u32aj2TeC+D13f7scFSIfphw2pmu4LaKWMSY8=" crossorigin=anonymous></script><script src=/dot-dom/js/dotdom.min.js></script><script src=/dot-dom/js/dotdom-example.js></script><link rel=stylesheet href=/dot-dom/css/styles.css></head><body><input type=checkbox class=hidden id=menu-control><main class="flex container"><aside class="book-menu fixed"><nav><h2 class=book-brand><a href=https://wavesoft.github.io/dot-dom/><span>.dom Documentation</span></a></h2><div class=book-search><input type=text placeholder=Search id=book-search-input maxlength=64><div class="book-search-spinner spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><span>Installation</span><ul><li><a href=/dot-dom/docs/install/getting-started/>Getting Started</a></li><li><a href=/dot-dom/docs/install/add-to-website/>Adding .dom in your website</a></li><li><a href=/dot-dom/docs/install/create-web-app/>Creating a WebApp</a></li><li><a href=/dot-dom/docs/install/serving-compressed/>Serving GZ version of .dom</a></li></ul></li><li><span>Topics</span><ul><li><a href=/dot-dom/docs/topics/quick-start/>Quick Start</a></li><li><a href=/dot-dom/docs/topics/declarative/>Declarative DOM</a></li><li><a href=/dot-dom/docs/topics/components/>Components</a></li><li><a href=/dot-dom/docs/topics/stateful-components/>Stateful Components</a></li><li><a href=/dot-dom/docs/topics/component-lifecycle/>Component Lifecycle</a></li><li><a href=/dot-dom/docs/topics/raw/>Raw Components</a></li><li><a href=/dot-dom/docs/topics/reconciliation/ class=active>Reconciliation</a></li><li><a href=/dot-dom/docs/topics/gotchas/>Gotchas</a></li></ul></li><li><span>API Reference</span><ul><li><a href=/dot-dom/docs/api/globals/>Globals</a></li><li><a href=/dot-dom/docs/api/component-functions/>Component Functions</a></li><li><a href=/dot-dom/docs/api/vdom-element/>VDom Element</a></li></ul></li></ul></nav><script>(function(){var menu=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(event){localStorage.setItem("menu.scrollTop",menu.scrollTop);});menu.scrollTop=localStorage.getItem("menu.scrollTop");})();</script></aside><div class=book-page><header class="flex align-center justify-between book-header"><label for=menu-control><img src=/dot-dom/svg/menu.svg alt=Menu></label>
<strong>Reconciliation</strong></header><article class=markdown><h1 id=reconciliation>Reconciliation</h1><p>Because of it&rsquo;s declarative nature, <code>.dom</code> knows which elements to update on a reconciliation events, so there is no requirement by the developer to explicitly control this process.</p><p>In this document we are describing the details of the reconciliation process of the library, since there are some specific cases where the developer should pay attention. Especially when designing performance-critical interfaces.</p><hr><h2 id=reconciliation-in-dom>Reconciliation in <code>.dom</code></h2><blockquote class="book-hint warning">First and foremost is important to clarify that <code>.dom</code> is optimized for <em>size</em> and not for <em>performance</em>. This means that instead of following particular algorithmic &ldquo;best practices&rdquo; we are using quirks and intentional code repetitions that helps compression algorithms produce a smaller result.</blockquote><p>When &ldquo;diffing&rdquo; the VDom (in-memory Virtual DOM) with the DOM (the actual page DOM) trees, <code>.dom</code> compares the children of a DOM element with an array of VDom elements.</p><p>For each element, the operation that takes place depends on the type of the two elements encountered.</p><h3 id=elements-of-different-types>Elements Of Different Types</h3><p>When the diffing algorithm encounters two elements of different types, it tears down the old tree and creates a new tree from scratch.</p><p>This includes switching from one tag to another (eg. <code>&lt;span&gt;</code> to <code>&lt;div&gt;</code>), switching form one component to another (eg. <code>&lt;Head&gt;</code> to <code>&lt;Banner&gt;</code>) or switching from a tag to a component or vice versa (eg. <code>&lt;div&gt;</code> to <code>&lt;Content&gt;</code>).</p><p>Note that the state of a component is bound to it&rsquo;s root element. This means that if it&rsquo;s parent element is removed and re-created, the component state will also be lost. For example:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>div</span>&gt;
  &lt;<span style=color:#f92672>Counter</span> /&gt;
&lt;/<span style=color:#f92672>div</span>&gt;

&lt;<span style=color:#f92672>span</span>&gt;
  &lt;<span style=color:#f92672>Counter</span> /&gt;
&lt;/<span style=color:#f92672>span</span>&gt;</code></pre></div><h3 id=elements-of-same-types>Elements Of Same Types</h3><p>When the diffing algorithm encounters two elements of the same type, it updates the DOM element properties with the VDom element properties that have changed.</p><p>If the DOM element is a root of a component, it&rsquo;s update (<code>.u</code>) callback will be triggered.</p><h2 id=recursing-on-children>Recursing On Children</h2><p>By default, when recursing on the children of a DOM node, <code>.dom</code> just iterates over both lists of children at the same time and generates a mutation whenever thereâ€™s a difference.</p><p>For example, when adding an element at the end of the children, converting between these two trees works well:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>ul</span>&gt;
  &lt;<span style=color:#f92672>li</span>&gt;first&lt;/<span style=color:#f92672>li</span>&gt;
  &lt;<span style=color:#f92672>li</span>&gt;second&lt;/<span style=color:#f92672>li</span>&gt;
&lt;/<span style=color:#f92672>ul</span>&gt;

&lt;<span style=color:#f92672>ul</span>&gt;
  &lt;<span style=color:#f92672>li</span>&gt;first&lt;/<span style=color:#f92672>li</span>&gt;
  &lt;<span style=color:#f92672>li</span>&gt;second&lt;/<span style=color:#f92672>li</span>&gt;
  &lt;<span style=color:#f92672>li</span>&gt;third&lt;/<span style=color:#f92672>li</span>&gt;
&lt;/<span style=color:#f92672>ul</span>&gt;</code></pre></div><p>The diffing algorithm will match the two <code>&lt;li&gt;first&lt;/li&gt;</code> trees, match the two <code>&lt;li&gt;second&lt;/li&gt;</code> trees, and then insert the <code>&lt;li&gt;third&lt;/li&gt;</code> tree.</p><p>If you implement it naively, inserting an element at the beginning has worse performance. For example, converting between these two trees works poorly:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>ul</span>&gt;
  &lt;<span style=color:#f92672>li</span>&gt;Foo&lt;/<span style=color:#f92672>li</span>&gt;
  &lt;<span style=color:#f92672>li</span>&gt;Bar&lt;/<span style=color:#f92672>li</span>&gt;
&lt;/<span style=color:#f92672>ul</span>&gt;

&lt;<span style=color:#f92672>ul</span>&gt;
  &lt;<span style=color:#f92672>li</span>&gt;Baz&lt;/<span style=color:#f92672>li</span>&gt;
  &lt;<span style=color:#f92672>li</span>&gt;Foo&lt;/<span style=color:#f92672>li</span>&gt;
  &lt;<span style=color:#f92672>li</span>&gt;Bar&lt;/<span style=color:#f92672>li</span>&gt;
&lt;/<span style=color:#f92672>ul</span>&gt;</code></pre></div><p>This will mutate every child instead of realizing it can keep the <code>&lt;li&gt;Foo&lt;/li&gt;</code> and <code>&lt;li&gt;Bar&lt;/li&gt;</code> subtrees intact. This inefficiency can be a problem.</p><h3 id=keys>Keys</h3><p>In order to solve this issue, <code>.dom</code> supports a key attribute. When children have keys, <code>.dom</code> uses the key to match children in the original tree with children in the subsequent tree. For example, adding a key to our inefficient example above can make the tree conversion efficient:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=color:#a6e22e>ul</span>(
  <span style=color:#a6e22e>li</span>({<span style=color:#a6e22e>k</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;2015&#34;</span>}, <span style=color:#e6db74>&#34;Foo&#34;</span>),
  <span style=color:#a6e22e>li</span>({<span style=color:#a6e22e>k</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;2016&#34;</span>}, <span style=color:#e6db74>&#34;Bar&#34;</span>)
)

<span style=color:#a6e22e>ul</span>(
  <span style=color:#a6e22e>li</span>({<span style=color:#a6e22e>k</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;2014&#34;</span>}, <span style=color:#e6db74>&#34;Baz&#34;</span>),
  <span style=color:#a6e22e>li</span>({<span style=color:#a6e22e>k</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;2015&#34;</span>}, <span style=color:#e6db74>&#34;Foo&#34;</span>),
  <span style=color:#a6e22e>li</span>({<span style=color:#a6e22e>k</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;2016&#34;</span>}, <span style=color:#e6db74>&#34;Bar&#34;</span>),
)
</code></pre></div><p>Now <code>.dom</code> knows that the element with key <code>'2014'</code> is the new one, and the elements with the keys <code>'2015'</code> and <code>'2016'</code> have just moved.</p><p>In practice, finding a key is usually not hard. The element you are going to display may already have a unique ID, so the key can just come from your data:</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html>&lt;<span style=color:#f92672>li</span> <span style=color:#a6e22e>key</span><span style=color:#f92672>=</span><span style=color:#e6db74>{item.id}</span>&gt;{item.name}&lt;/<span style=color:#f92672>li</span>&gt;</code></pre></div><p>When thatâ€™s not the case, you can add a new ID property to your model or hash some parts of the content to generate a key. The key only has to be unique among its siblings, not globally unique.</p><p>As a last resort, you can pass an itemâ€™s index in the array as a key. This can work well if the items are never reordered, but reorders will be slow.</p><hr><div class=topic-nav><div><div>Previous Topic</div><div><a href=https://wavesoft.github.io/dot-dom/docs/topics/raw/ class=book-btn>&larr; Raw Components</a></div></div><div class=right><div>Next Topic</div><div><a href=https://wavesoft.github.io/dot-dom/docs/topics/gotchas/ class=book-btn>Gotchas &rarr;</a></div></div></div></article></div><aside class="book-toc level-6 fixed"><nav id=TableOfContents><ul><li><a href=#reconciliation>Reconciliation</a><ul><li><a href=#reconciliation-in-dom>Reconciliation in <code>.dom</code></a><ul><li><a href=#elements-of-different-types>Elements Of Different Types</a></li><li><a href=#elements-of-same-types>Elements Of Same Types</a></li></ul></li><li><a href=#recursing-on-children>Recursing On Children</a><ul><li><a href=#keys>Keys</a></li></ul></li></ul></li></ul></nav></aside></main></body></html>