<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Topics on .dom Documentation</title><link>https://wavesoft.github.io/dot-dom/docs/topics/</link><description>Recent content in Topics on .dom Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://wavesoft.github.io/dot-dom/docs/topics/index.xml" rel="self" type="application/rss+xml"/><item><title>Quick Start</title><link>https://wavesoft.github.io/dot-dom/docs/topics/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/quick-start/</guid><description> Quick Start The smallest .dom example looks like this:
R( H(&amp;#34;p&amp;#34;, &amp;#34;Hello World&amp;#34;), document.body ); It displays a paragraph, saying &amp;ldquo;Hello World&amp;rdquo; in the page, using the Declarative DOM Composition syntax.
Feel free to make some changes, and see how they affect the output. Alternatively, you can click the link below to open an online editor:
Try it in CodePen
Next Topic Declarative DOM &amp;rarr;</description></item><item><title>Declarative DOM</title><link>https://wavesoft.github.io/dot-dom/docs/topics/declarative/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/declarative/</guid><description>Declarative DOM Composition The .dom library comes with a built-in accelerators that makes it possible to rapidly design human-readable DOM layouts without the need of JSX, or any other Javascript preprocessor.
This is achieved through Proxy methods built on top of the .H (create element) function, creating a native Javascript syntactic sugar:
div( div.underline( &amp;#34;Welcome!&amp;#34; ), p( &amp;#34;In this example we demonstrate &amp;#34;, &amp;#34;the &amp;#34;, b(&amp;#34;.dom&amp;#34;), &amp;#34; accelerators.&amp;#34; ), p( &amp;#34;Create &amp;#34;, span.</description></item><item><title>Components</title><link>https://wavesoft.github.io/dot-dom/docs/topics/components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/components/</guid><description>Components Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.
Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called &amp;ldquo;props&amp;rdquo;) and return Virtual DOM elements describing what should appear on the screen.
Component Functions All components in .dom are Javascript functions:
const { div } = H; function Welcome(props) { return div(`Hello ${props.name}`); } This function is a valid .</description></item><item><title>Stateful Components</title><link>https://wavesoft.github.io/dot-dom/docs/topics/stateful-components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/stateful-components/</guid><description>Stateful Components Components can only carry properties given, but can also maintain their own state.
For example, consider the case of a spinner widget, where the user has two buttons : one to increment the value and one to decrement, like so:
const { div, button } = H; function Spinner(props) { return div.rowflex( button(&amp;#34;-&amp;#34;), div(`${props.value}`), button(&amp;#34;&amp;#43;&amp;#34;) ); } R(H(Spinner, {value: 0}), document.body); But what should happen when the user clicks the &amp;ldquo;+&amp;rdquo; or the &amp;ldquo;-&amp;rdquo; button?</description></item><item><title>Component Lifecycle</title><link>https://wavesoft.github.io/dot-dom/docs/topics/component-lifecycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/component-lifecycle/</guid><description>Component Lifecycle Every .dom component undergoes through a three phases during it&amp;rsquo;s life-cycle : Mounted, Updated and Unmounted
As a developer, you can react to these life-cycle events in order to implement your logic.
Component Hooks You can register callback handlers to either of the three life-cycle events through the hooks object, that is given as a 4th argument to the Component function:
function Component(props, state, setState, hooks) { // .</description></item><item><title>Raw Components</title><link>https://wavesoft.github.io/dot-dom/docs/topics/raw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/raw/</guid><description>Raw Components If you are controlling the created HTML DOM instance yourself, you can mark the node as raw to disable deeper reconciliation.
By default, on every update, .dom will reconcile the children of each VNode instance. This will destroy any previous modifications to the DOM. To disable this functionality, set hooks.r to a truthy value (eg. 1 or true):
const RawComponent = (props, state, setState, hooks) =&amp;gt; { // Mark the component as raw hooks.</description></item><item><title>Keyed Updates</title><link>https://wavesoft.github.io/dot-dom/docs/topics/keyed-updates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/keyed-updates/</guid><description> Keyed Updates When reconciling the children of a Virtual Node, .dom is using string keys to resolve their order.
Previous Topic &amp;larr; Raw Components</description></item></channel></rss>