<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Topics on .dom Documentation</title><link>https://wavesoft.github.io/dot-dom/docs/topics/</link><description>Recent content in Topics on .dom Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://wavesoft.github.io/dot-dom/docs/topics/index.xml" rel="self" type="application/rss+xml"/><item><title>Quick Start</title><link>https://wavesoft.github.io/dot-dom/docs/topics/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/quick-start/</guid><description> Quick Start The smallest .dom example looks like this:
UigKICBIKCYjMzQ7cCYjMzQ7LCAmIzM0O0hlbGxvIFdvcmxkJiMzNDspLAogIGRvY3VtZW50LmJvZHkKKTs= Loading interactive example... It displays a paragraph, saying &amp;ldquo;Hello World&amp;rdquo; in the page, using the Declarative DOM Composition syntax.
Feel free to make some changes, and see how they affect the output. Alternatively, you can click the link below to open an online editor:
Try it in CodePen
Next Topic Declarative DOM &amp;rarr;</description></item><item><title>Declarative DOM</title><link>https://wavesoft.github.io/dot-dom/docs/topics/declarative/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/declarative/</guid><description>Declarative DOM Composition The .dom library comes with a built-in accelerators that makes it possible to rapidly design human-readable DOM layouts without the need of JSX, or any other Javascript preprocessor.
This is achieved through Proxy methods built on top of the .H (create element) function, creating a native Javascript syntactic sugar:
ZGl2KAogIGRpdi51bmRlcmxpbmUoCiAgICAmIzM0O1dlbGNvbWUhJiMzNDsKICApLAogIHAoCiAgICAmIzM0O0luIHRoaXMgZXhhbXBsZSB3ZSBkZW1vbnN0cmF0ZSAmIzM0OywKICAgICYjMzQ7dGhlICYjMzQ7LCBiKCYjMzQ7LmRvbSYjMzQ7KSwgJiMzNDsgYWNjZWxlcmF0b3JzLiYjMzQ7CiAgKSwKICBwKAogICAgJiMzNDtDcmVhdGUgJiMzNDssIHNwYW4ucmVkKCYjMzQ7cG93ZXJmdWwmIzM0OyksCiAgICAmIzM0OyBsYXlvdXRzIHdpdGggJiMzNDssIGIoJiMzNDtuYXRpdmUgSlMhJiMzNDspCiAgKQop Loading interactive example... .tag Accelerators When accessing a property out of the H function, a new function is composed, with the tag argument, bound to a tag named as the property.</description></item><item><title>Components</title><link>https://wavesoft.github.io/dot-dom/docs/topics/components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/components/</guid><description>Components Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.
Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called &amp;ldquo;props&amp;rdquo;) and return Virtual DOM elements describing what should appear on the screen.
Component Functions All components in .dom are Javascript functions:
const { div } = H; function Welcome(props) { return div(`Hello ${props.name}`); } This function is a valid .</description></item><item><title>Stateful Components</title><link>https://wavesoft.github.io/dot-dom/docs/topics/stateful-components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/stateful-components/</guid><description>Stateful Components Components can only carry properties given, but can also maintain their own state.
For example, consider the case of a spinner widget, where the user has two buttons : one to increment the value and one to decrement, like so:
Y29uc3QgeyBkaXYsIGJ1dHRvbiB9ID0gSDsKCmZ1bmN0aW9uIFNwaW5uZXIocHJvcHMpIHsKICByZXR1cm4gZGl2LnJvd2ZsZXgoCiAgICBidXR0b24oJiMzNDstJiMzNDspLAogICAgZGl2KGAke3Byb3BzLnZhbHVlfWApLAogICAgYnV0dG9uKCYjMzQ7KyYjMzQ7KQogICk7Cn0KClIoSChTcGlubmVyLCB7dmFsdWU6IDB9KSwgZG9jdW1lbnQuYm9keSk7 Loading interactive example... But what should happen when the user clicks the &amp;ldquo;+&amp;rdquo; or the &amp;ldquo;-&amp;rdquo; button? To answer this question we will introduce you to the Component State</description></item><item><title>Component Lifecycle</title><link>https://wavesoft.github.io/dot-dom/docs/topics/component-lifecycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/component-lifecycle/</guid><description>Component Lifecycle Every .dom component undergoes through a three phases during it&amp;rsquo;s life-cycle : Mounted, Updated and Unmounted
As a developer, you can react to these life-cycle events in order to implement your logic.
Component Hooks You can register callback handlers to either of the three life-cycle events through the hooks object, that is given as a 4th argument to the Component function:
function Component(props, state, setState, hooks) { // .</description></item><item><title>Raw Components</title><link>https://wavesoft.github.io/dot-dom/docs/topics/raw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/raw/</guid><description>Raw Components If you are controlling the created HTML DOM instance yourself, you can mark the node as raw to disable deeper reconciliation.
By default, on every update, .dom will reconcile the children of each VNode instance. This will destroy any previous modifications to the DOM. To disable this functionality, set hooks.r to a truthy value (eg. 1 or true):
const RawComponent = (props, state, setState, hooks) =&amp;gt; { // Mark the component as raw hooks.</description></item><item><title>Reconciliation</title><link>https://wavesoft.github.io/dot-dom/docs/topics/reconciliation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/reconciliation/</guid><description>Reconciliation Because of it&amp;rsquo;s declarative nature, .dom knows which elements to update on a reconciliation events, so there is no requirement by the developer to explicitly control this process.
In this document we are describing the details of the reconciliation process of the library, since there are some specific cases where the developer should pay attention. Especially when designing performance-critical interfaces.
Reconciliation in .dom First and foremost is important to clarify that .</description></item><item><title>Gotchas</title><link>https://wavesoft.github.io/dot-dom/docs/topics/gotchas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/gotchas/</guid><description>Gotchas Since .dom is optimized for size and not for performance nor developer friendliness, you should be aware that there are few rough edges.
Component roots cannot change The component state is preserved on it&amp;rsquo;s root DOM element. On it&amp;rsquo;s own turn, this element is indexed by the component&amp;rsquo;s key.
This means, that once mounted, the component won&amp;rsquo;t be able to change the type of the root element, since it will be persisted in the cache.</description></item></channel></rss>