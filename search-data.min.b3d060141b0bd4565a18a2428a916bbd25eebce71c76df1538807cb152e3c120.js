(function(){const pages=[{"idx":0,"href":"/dot-dom/docs/install/getting-started/","title":"Getting Started","content":" Getting Started Welcome to the exciting world of .dom.\nThere are various ways you can experiment or integrate .dom in your use case.\n You can use the on-line playground You can integrate .dom in your website You can create a web-app with it  Or you can keep reading to learn more about it.\nNext Topic  Adding .dom in your website \u0026rarr;     "},{"idx":1,"href":"/dot-dom/docs/api/globals/","title":"Globals","content":" Globals When sourced, .dom library exposes a few entry point functions for defining and rendering elements.\n.H - Create Element H( \u0026#39;tag\u0026#39; ) H( \u0026#39;tag\u0026#39;, {prop: \u0026#34;value\u0026#34;}) H( \u0026#39;tag\u0026#39;, H( \u0026#39;child\u0026#39; )) H( \u0026#39;tag\u0026#39;, {prop: \u0026#34;value\u0026#34;}, H( \u0026#39;child\u0026#39; )) H( Component, {prop: \u0026#34;value\u0026#34;} )  Create and return a new VDom element of the given type. The type argument can be either a tag name string (such as \u0026lsquo;div\u0026rsquo; or \u0026lsquo;span\u0026rsquo;) or a Component function.\nIf you are using JSX, your code will be converted to use the H() function. You will not typically invoke H() directly. Refer to the JSX Integration for more details.\nTag Shorthands The exposed .H variable is not a simple function, but rather a multi-functional object.\nAccessing any property under the .H object, will return the same .H function, but with the first argument bound to a tag name same as the property being accessed.\nH.div(\u0026#34;Hello\u0026#34;) // equals H(\u0026#39;div\u0026#39;, \u0026#34;Hello\u0026#34;)  This feature is the foundation of the Declarative DOM Composition. Refer to the guide for more details.\n.R - Render R( VirtualDOM, HTLDomElement ) R( [VirtualDOM, ...], HTLDomElement )  Renders the given VDom tree as children of the given HTML DOM element. The first argument can either be a single VDom element or an array of VDom elements.\n"},{"idx":2,"href":"/dot-dom/docs/topics/quick-start/","title":"Quick Start","content":" Quick Start The smallest .dom example looks like this:\nR( H(\u0026#34;p\u0026#34;, \u0026#34;Hello World\u0026#34;), document.body ); It displays a paragraph, saying \u0026ldquo;Hello World\u0026rdquo; in the page, using the Declarative DOM Composition syntax.\nFeel free to make some changes, and see how they affect the output. Alternatively, you can click the link below to open an online editor:\nTry it in CodePen\nNext Topic  Declarative DOM \u0026rarr;     "},{"idx":3,"href":"/dot-dom/docs/install/add-to-website/","title":"Adding .dom in your website","content":" Adding .dom in your website Use it according to your needs.\nThe .dom library is quite agile and can be used either in existing websites, where you just want to add some interactivity, or in a modern single-page app.\nBoilerplate If you want to start from scratch, you can use the following HTML boilerplate:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;My .dom App\u0026lt;/title\u0026gt; \u0026lt;!-- The .dom library sources --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/wavesoft/dot-dom/dotdom.min.js\u0026#34; integrity=\u0026#34;sha384-iYmnbr5e65SuCt6QZydA\u0026#43;bdS7Lojxq0yNp0S/c68OsYQa8bklHnsBiWC9bE6GhJW\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;!-- The root container where the app will be rendered --\u0026gt; \u0026lt;div id=\u0026#34;main\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;!-- Your App --\u0026gt; \u0026lt;script\u0026gt; // Define some DOM accelerators  const { p } = H; // Define your app entry point component  const App = () =\u0026gt; { return p(\u0026#34;Hello World!\u0026#34;); }; // Render the main app  R(H(App), document.getElementById(\u0026#34;main\u0026#34;)); \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Adding to an existing website If you already have a website and you just want to make some parts of it interactive, you can add .dom in three simple steps:\nStep 1 - Add a main view container First you should create an empty element in the place you want .dom to render it\u0026rsquo;s contents:\n\u0026lt;!-- Here is where .dom will render it\u0026#39;s contents --\u0026gt; \u0026lt;div id=\u0026#34;main\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; Step 2 - Add script tags Then you should load the .dom library in your website. You can either download it and put it along with the rest of your website assets, or you can use a CDN link:\n\u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/gh/wavesoft/dot-dom/dotdom.min.js\u0026#34; integrity=\u0026#34;sha384-iYmnbr5e65SuCt6QZydA\u0026#43;bdS7Lojxq0yNp0S/c68OsYQa8bklHnsBiWC9bE6GhJW\u0026#34; crossorigin=\u0026#34;anonymous\u0026#34;\u0026gt; \u0026lt;/script\u0026gt;  Step 3 - Define your components and render You are now ready to define your components and render your app. You can do this by adding a \u0026lt;script\u0026gt; tag in your body:\n\u0026lt;script\u0026gt; // Define some DOM accelerators  const { p } = H; // Define your app entry point component  const App = () =\u0026gt; { return p(\u0026#34;Hello World!\u0026#34;); }; // Render the main app  R(H(App), document.getElementById(\u0026#34;main\u0026#34;)); \u0026lt;/script\u0026gt;   Previous Topic  \u0026larr; Getting Started    Next Topic  Creating a WebApp \u0026rarr;     "},{"idx":4,"href":"/dot-dom/docs/api/component-functions/","title":"Component Functions","content":" Component Functions This page explains in detail the component functions.\nEvery component function is called during the rendering phase of the DOM and it must return a valid VDom element to render. Any code logic that should be called during a particular lifecycle event of the node should be registered via the hooks object.\nfunction Component(props, state, setState, hooks) { return ... }   props : The properties object, as given by the user in the H function state : An object that contains the state values of the object setState : A function that can be used to update the state and re-render the element hooks : An object where you can register the lifecycle method hooks  Note that the state object instance remains untouched throughout the life-cycle of the component. This means that you can use it for keeping local properties without triggering a re-render.  setState() setState( Object )  The setState function updates the local component state and re-renders it.\nImportant! When in the same handler you call setState and also call a handler function that you received as property, make sure to call setState first and then call-out to the handler.\n// First call setState  setState({ value: newValue }); // And **then** call-out to handlers  if (props.onChange) props.onChange();  That\u0026rsquo;s due to a limitation in the internals of the .dom engine, that could lead into invalid state updates if the parent element updates before the child element!\n The properties given in the object will be shallow-merged with the properties in the state.\nFor example, when given a state:\n{ foo: \u0026#34;foo\u0026#34;, bar: \u0026#34;bar\u0026#34;, deep: { a: 1 } };  Calling:\nsetState({ foo: \u0026#34;bar\u0026#34;, deep: { b: 2 } });  Will produce the following (note the value of deep property):\n{ foo: \u0026#34;bar\u0026#34;, bar: \u0026#34;bar\u0026#34;, deep: { b: 2 } };  hooks{ } { m : [], // Array of didMount() callbacks  u : [], // Array of willUnmount() callbacks  d : [], // Array of didUpdate() callbacks  r : false // Raw Component Indicator }  The hooks object can be used for registering lifecycle callbacks for your component.\n.m - didMount() hooks.m.push( function( domInstance ) { ... } )  The mount callbacks are called when the component has finished mounting itself in the DOM.\nThe first argument given is the instance of the root DOM element.\n.u - didUnmount() hooks.u.push( function( domInstance ) { ... } )  The unmount callbacks are called when the component has finished removing itself from the DOM.\nThe first argument given is the instance of the root DOM element.\n.d - didUpdate() hooks.u.push( function( domInstance ) { ... } )  The update callbacks are called when the component has finished updating it\u0026rsquo;s properties.\nThe first argument given is the instance of the root DOM element.\n.r - Raw Flag hooks.r = \u0026lt;truthy\u0026gt; | \u0026lt;falsy\u0026gt;  The raw flag indicates that this component is \u0026ldquo;raw\u0026rdquo; (eg. manipulates it\u0026rsquo;s own DOM children) and should be opted-out from .dom reconciliation logic.\nYou can set any truthy value to enable this flag (true, 1, \u0026quot;\u0026quot;, {}, [], etc.)\n"},{"idx":5,"href":"/dot-dom/docs/topics/declarative/","title":"Declarative DOM","content":" Declarative DOM Composition The .dom library comes with a built-in accelerators that makes it possible to rapidly design human-readable DOM layouts without the need of JSX, or any other Javascript preprocessor.\nThis is achieved through Proxy methods built on top of the .H (create element) function, creating a native Javascript syntactic sugar:\ndiv( div.underline( \u0026#34;Welcome!\u0026#34; ), p( \u0026#34;In this example we demonstrate \u0026#34;, \u0026#34;the \u0026#34;, b(\u0026#34;.dom\u0026#34;), \u0026#34; accelerators.\u0026#34; ), p( \u0026#34;Create \u0026#34;, span.red(\u0026#34;powerful\u0026#34;), \u0026#34; layouts with \u0026#34;, b(\u0026#34;native JS!\u0026#34;) ) ) .tag Accelerators When accessing a property out of the H function, a new function is composed, with the tag argument, bound to a tag named as the property.\nTypically you should use the ES6 destructuring operator in the beginning of your script to create helpers for the HTML entities you are using later. For example:\nconst { div, b, i } = H;  This allows us to compose an HTML document in a natural manner like so:\ndiv( div(\u0026#34;Name: \u0026#34;, b(\u0026#34;John\u0026#34;)), div(\u0026#34;Surname: \u0026#34;, i(\u0026#34;Doe\u0026#34;)) ) .class Accelerators When further accessing properties in the tag accelerator, a new function is composed that appends the property name in the list of the element\u0026rsquo;s CSS class names.\nThere is no limit on how many classes you can append, you can keep accessing deeper properties, and each time you will be appending a class name:\ndiv( p.red.underline(\u0026#34;Hello world!\u0026#34;), // You can also create classes by string // as you would normally do with any // javascript object p[\u0026#39;green\u0026#39;](\u0026#34;Welcome to the world \u0026#34;, span[\u0026#39;blue\u0026#39;].underline(\u0026#34;of .dom!\u0026#34;) ) )  Previous Topic  \u0026larr; Quick Start    Next Topic  Components \u0026rarr;     "},{"idx":6,"href":"/dot-dom/docs/install/create-web-app/","title":"Creating a WebApp","content":" Creating a WebApp Since .dom natively supports JSX integration you can use a similar tooling like React to create a single-page application.\nIn this page we are describing step-by-step the process you should follow in order to create a single-page application using webpack and babel.\nStarting a node project First we should start by creating a blank new node.js project:\nmkdir my-dotdom-app; cd my-dotdom-app yarn init -y Setting-up Dependencies We are going to use webpack as our main build tool. It is responsible for packaging all of our project assets into bundles, pre-processing them with some filters if needed. Let\u0026rsquo;s add it:\nyarn add -D webpack webpack-cli webpack-dev-server In our case, we are going to use the React JSX extensions to Javascript. This is implemented as an Babel plugin. So let\u0026rsquo;s add it:\nyarn add -D babel-loader @babel/core @babel/preset-env @babel/plugin-transform-react-jsx And finally, we should add the dot-dom library:\nyarn add dot-dom Adding boilerplate code Let\u0026rsquo;s continue creating the structure of our project, and more specifically the entry point for our javascript and HTML part in the following locations:\n- src/ -- index.js - dist/ -- index.html  The src/index.js is the entry point to our web app. Create it with following contents:\nimport DotDom from \u0026#39;dot-dom\u0026#39;; DotDom.R( \u0026lt;h1\u0026gt;.dom and JSX\u0026lt;/h1\u0026gt;, document.getElementById(\u0026#39;app\u0026#39;) ); The dist/index.html is the static HTML page that loads our application bundle. Create it with following contents:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Hello .dom\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;./bundle.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Configuring Webpack For our next step, we should configure webpack. More specifically we must instruct it to pass all the .js or .jsx sources through the babel-loader plugin, that is going to translate the JSX expressions in our source code.\nCreate a file called webpack.config.js with the following contents:\nmodule.exports = { entry: \u0026#39;./src/index.js\u0026#39;, module: { rules: [ { test: /\\.(js)$/, exclude: /node_modules/, use: [\u0026#39;babel-loader\u0026#39;] } ] }, output: { path: __dirname + \u0026#39;/dist\u0026#39;, publicPath: \u0026#39;/\u0026#39;, filename: \u0026#39;bundle.js\u0026#39; }, devServer: { contentBase: \u0026#39;./dist\u0026#39; } };  The babel plugin is further configured with a separate file. You must then create a file called .babelrc in the root directory of your project with the following contents:\n{ \u0026#34;presets\u0026#34;: [ \u0026#34;@babel/preset-env\u0026#34; ], \u0026#34;plugins\u0026#34;: [ [\u0026#34;@babel/plugin-transform-react-jsx\u0026#34;, { \u0026#34;pragma\u0026#34;: \u0026#34;DotDom.H\u0026#34; }] ] } Adding build scripts It\u0026rsquo;s a good practice to add the following build scripts in your package.json:\n... \u0026#34;scripts\u0026#34;: { \u0026#34;build\u0026#34;: \u0026#34;webpack --mode production\u0026#34;, \u0026#34;start\u0026#34;: \u0026#34;webpack-dev-server --mode development\u0026#34; }, ... This will allow you to build your project by simply running yarn build, or start a development server by running yarn start.\nTrying it out You are now ready to start the webpack development server and see your project.\nyarn start You can now open http://127.0.0.1:8080 and see your app.\n Previous Topic  \u0026larr; Adding .dom in your website    Next Topic  Serving GZ version of .dom \u0026rarr;     "},{"idx":7,"href":"/dot-dom/docs/topics/components/","title":"Components","content":" Components Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.\nConceptually, components are like JavaScript functions. They accept arbitrary inputs (called \u0026ldquo;props\u0026rdquo;) and return Virtual DOM elements describing what should appear on the screen.\nComponent Functions All components in .dom are Javascript functions:\nconst { div } = H; function Welcome(props) { return div(`Hello ${props.name}`); }  This function is a valid .dom component because it accepts a \u0026ldquo;props\u0026rdquo; object argument and returns a Virtual DOM element.\nRendering Components We have previously seen that you can render HTML elements using the H function:\nconst elm = H(\u0026#34;div\u0026#34;, \u0026#34;Hello world\u0026#34;);  You can use the same function to render components.\nconst elm = H(Welcome, {\u0026#34;name\u0026#34;: \u0026#34;World\u0026#34;});  Note that you cannot use the deconstructuring accelerator with Components. You must always call H(Component) to render it.  The library will call-out to your component, passing down the props given and will collect the resulting VDom tree.\nYou can see this in action:\nconst { div } = H; // Define the component function Welcome(props) { return div(`Hello ${props.name}`); } // Render it R( H(Welcome, {\u0026#34;name\u0026#34;: \u0026#34;World\u0026#34;}), document.body ); Composing Components Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in a .dom app, all those are commonly expressed as components.\nconst { div } = H; // Define the component function Welcome(props) { return div(`Hello ${props.name}`); } // Define the app function App(props) { return div( H(Welcome, {name: \u0026#34;Foo\u0026#34;}), H(Welcome, {name: \u0026#34;Bar\u0026#34;}), H(Welcome, {name: \u0026#34;Baz\u0026#34;}) ); } // Render the app R( H(App), document.body );  Previous Topic  \u0026larr; Declarative DOM    Next Topic  Stateful Components \u0026rarr;     "},{"idx":8,"href":"/dot-dom/docs/topics/stateful-components/","title":"Stateful Components","content":" Stateful Components Components can only carry properties given, but can also maintain their own state.\nFor example, consider the case of a spinner widget, where the user has two buttons : one to increment the value and one to decrement, like so:\nconst { div, button } = H; function Spinner(props) { return div.rowflex( button(\u0026#34;-\u0026#34;), div(`${props.value}`), button(\u0026#34;\u0026#43;\u0026#34;) ); } R(H(Spinner, {value: 0}), document.body); But what should happen when the user clicks the \u0026ldquo;+\u0026rdquo; or the \u0026ldquo;-\u0026rdquo; button? To answer this question we will introduce you to the Component State\nComponent State Every component is created with an empty state object, initialized to { }. This object persists throughout the life-cycle of the component and is disposed when unmounted.\nThe component can update it\u0026rsquo;s state by calling the setState method, giving the new values for the state properties. This will cause the element to re-render in order to apply the new values.\nThe state and setState variables are passed as arguments to the component function, right after the props object:\nfunction Welcome(props, state, setState) { // ... }  This means that we can now re-write our spinner widget using the state object like so:\nconst { div, button } = H; function Spinner( props, {value=props.value}, setState ) { return div.rowflex( // Decrement button button({ onclick() { setState({ value: value - 1 }) } }, \u0026#34;-\u0026#34;), // Value label div(`${value}`), // Increment button button({ onclick() { setState({ value: value \u0026#43; 1 }) } }, \u0026#34;\u0026#43;\u0026#34;) ); } R(H(Spinner, {value: 0}), document.body); State Propagation When designing stateful components, it\u0026rsquo;s important to find out where the state of your application will be. It is a good practice to keep the state to the top-most component and pass down portions of it, to stateless components.\nAs an exception of this rule, it is also acceptable to use stateful components that maintain a temporary state of a user-interfacing component.\nExample Consider the more complicated example of a ToDo List App. In this example, we are using three kinds of components:\n The TodoList component that renders the items and the input field The TodoItem component that renders a single item and allows the user to mark it as completed. The InputField where the user enters the new item text  In such cases it\u0026rsquo;s important to find out where the state is going to be maintained. It is typically a good practice to keep the state to the root component and pass down portions of it to stateless components.\nLet\u0026rsquo;s start designing our leaf components. First the TodoItem component:\nfunction TodoItem({ text, completed, oncomplete }) { return div.rowflex( button( { onclick: oncomplete}, \u0026#34;✔︎\u0026#34; ), div[completed ? \u0026#34;strike\u0026#34; : \u0026#34;\u0026#34;](text) ); }  This stateless component accepts the following properties:\n text : The text of the eleemtn completed : A boolean flag that indicates if the item is completed oncomplete : A callback function to call when the user completes the item  Then let\u0026rsquo;s design the InputField component:\nfunction InputField({ oncreate }, {text=\u0026#34;\u0026#34;}, setState) { return div.rowflex( input({ type: \u0026#39;text\u0026#39;, value: text, onchange(e) { setState({ text: e.target.value }) } }), button({ onclick() { setState({ text: \u0026#34;\u0026#34; }); oncreate(text); } }, \u0026#34;Create\u0026#34;) ) }  Important! When in the same handler you call setState and also call a handler function that you received as property, make sure to call setState first and then call-out to the handler.  This is a stateful component, that uses it\u0026rsquo;s local state only for keeping track of the user input. It still forwards the important events to the parent.\nIt accepts the following properties:\n oncreate : A callback function that will be called when the user clicks the \u0026ldquo;Create\u0026rdquo; button, passing down the value the user has entered.  And finally, let\u0026rsquo;s design the TodoList component:\nfunction TodoList(props, {items=[]}, setState) { const addItem = text =\u0026gt; { setState({ items: items.concat({ text, completed: false }) }) }; const checkItem = index =\u0026gt; { items[index].completed = !items[index].completed; setState({ items }); }; return div( items.map((item, index) =\u0026gt; H(TodoItem, { text: item.text, completed: item.completed, oncomplete: checkItem.bind(index) })), H(InputField, { oncreate: addItem }) ); }  And here is what the full example looks like:\nconst { div, button, input } = H; function TodoItem({ text, completed, oncomplete }) { return div.rowflex( button( { onclick: oncomplete}, \u0026#34;✔︎\u0026#34; ), div[completed ? \u0026#34;strike\u0026#34; : \u0026#34;\u0026#34;](text) ); } function InputField({ oncreate }, {text=\u0026#34;\u0026#34;}, setState) { return div.rowflex( input({ type: \u0026#39;text\u0026#39;, value: text, onchange(e) { setState({ text: e.target.value }) } }), button({ onclick() { setState({ text: \u0026#34;\u0026#34; }); oncreate(text); } }, \u0026#34;Create\u0026#34;) ) } function TodoList(props, state, setState) { const addItem = text =\u0026gt; { setState({ items: (state.items || []).concat({ text, completed: false }) }) }; const checkItem = index =\u0026gt; { state.items[index].completed = !state.items[index].completed; setState({ }); }; console.log(state.items); return div( H(InputField, { oncreate: addItem }), (state.items || []).map((item, index) =\u0026gt; H(TodoItem, { k: index, text: item.text, completed: item.completed, oncomplete: checkItem.bind(this, index) })), ); } R(H(TodoList), document.body);  Previous Topic  \u0026larr; Components    Next Topic  Component Lifecycle \u0026rarr;     "},{"idx":9,"href":"/dot-dom/docs/topics/component-lifecycle/","title":"Component Lifecycle","content":" Component Lifecycle Every .dom component undergoes through a three phases during it\u0026rsquo;s life-cycle : Mounted, Updated and Unmounted\nAs a developer, you can react to these life-cycle events in order to implement your logic.\nComponent Hooks You can register callback handlers to either of the three life-cycle events through the hooks object, that is given as a 4th argument to the Component function:\nfunction Component(props, state, setState, hooks) { // ... }  You can read more on the Component Functions API reference.\nMounting When a component is created (using the H) function, the newly created instance does not yet have a DOM reflection.\nWhen rendered, and the VDom element obtains a DOM reflection, the VNode is considered to be Mounted.\nAt this point, the .m (didMount) callback is fired. To subscribe for such events, push your handler in the .m array in the hooks object:\nfunction Component(props, state, setState, hooks) { hooks.m.push(function(domElement) { // Do something with the DOM element  }); }  In this handler you can initialize other libraries that are bound to this element. For instance ACE editor, or other WYSIWYG visual editors.  Unmounting When a component is about to be removed from DOM, the node is considered to be Unmounted. At this point, the .u (willUnmount) callback is fired. To subscribe for such events, push your handler in the .u array in the hooks object:\nfunction Component(props, state, setState, hooks) { hooks.u.push(function(domElement) { // Do something with the DOM element  }); }  Updating When a component has finished updating it\u0026rsquo;s properties, it fires the d (didUpdate) callbacks. To subscribe for such events, push your handler in the .d array in the hooks object:\nfunction Component(props, state, setState, hooks) { hooks.d.push(function(domElement) { // Do something with the DOM element  }); }   Previous Topic  \u0026larr; Stateful Components    Next Topic  Raw Components \u0026rarr;     "},{"idx":10,"href":"/dot-dom/docs/topics/raw/","title":"Raw Components","content":" Raw Components If you are controlling the created HTML DOM instance yourself, you can mark the node as raw to disable deeper reconciliation.\nBy default, on every update, .dom will reconcile the children of each VNode instance. This will destroy any previous modifications to the DOM. To disable this functionality, set hooks.r to a truthy value (eg. 1 or true):\nconst RawComponent = (props, state, setState, hooks) =\u0026gt; { // Mark the component as raw  hooks.r = 1; }  HTML Component One use of the raw components is to render plain HTML strings. For example:\nfunction RenderHTML({html}, state, setState, hooks) { hooks.r = true; return H(\u0026#34;div\u0026#34;, { innerHTML: html }) } R( H(RenderHTML, { html: \u0026#34;\u0026lt;p\u0026gt;Hello \u0026lt;b\u0026gt;World\u0026lt;/b\u0026gt;\u0026lt;/p\u0026gt;\u0026#34; }), document.body )  Previous Topic  \u0026larr; Component Lifecycle    Next Topic  Keyed Updates \u0026rarr;     "},{"idx":11,"href":"/dot-dom/docs/install/","title":"Installation","content":""},{"idx":12,"href":"/dot-dom/docs/topics/keyed-updates/","title":"Keyed Updates","content":" Keyed Updates When reconciling the children of a Virtual Node, .dom is using string keys to resolve their order.\n Previous Topic  \u0026larr; Raw Components     "},{"idx":13,"href":"/dot-dom/docs/install/serving-compressed/","title":"Serving GZ version of .dom","content":" Serving the compressed version of .dom If you want to serve .dom on it\u0026rsquo;s smallest possible size, you might want to serve it compressed.\nFor example, in embedded (eg. IoT) projects the device memory is quite limited. Therefore storing the uncompressed version of the library might not be desired. In such cases, you can always serve .dom directly on it\u0026rsquo;s compressed form.\nThis is achieved simply by setting the correct encoding response header while streaming the compressed library to the client:\nContent-Encoding: gzip  According to HTML standards you should always check the Accept-Encoding request header, and proceed with sending the compressed version of the library only if supported.\nHowever, based on recent analytics, more than 99% of the browsers in the market natively support the gzip encoding, making this a safe assumption.\n ESP32 Example If you are writing a firmware for an ESP32 chip, you can directly serve the compressed version of the library, following this guide.\nFirst, convert the compressed version of the library into a C array:\ncat dotdom.min.gz | xxd -i \u0026gt;\u0026gt; dot-dom.h Edit dot-dom.h, making sure the bytes are correctly wrapped in a static C array:\nstatic const uint8_t DOT_DOM_JS[] = { // xxd output ...  0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x13, 0x5d, 0x52, ... // ... up to here };  Then, in your HTTP handler just make sure to set the correct headers:\nstatic esp_err_t handle_get_dot_dom(httpd_req_t *req) { httpd_resp_set_hdr(req, \u0026#34;Content-Encoding\u0026#34;, \u0026#34;gzip\u0026#34;); httpd_resp_set_type(req, \u0026#34;application/javascript\u0026#34;); httpd_resp_send(req, DOT_DOM_JS, sizeof(DOT_DOM_JS)); return ESP_OK; }   Previous Topic  \u0026larr; Creating a WebApp     "},{"idx":14,"href":"/dot-dom/docs/topics/","title":"Topics","content":""},{"idx":15,"href":"/dot-dom/docs/api/","title":"API Reference","content":""},{"idx":16,"href":"/dot-dom/","title":"","content":".dom The tiniest (512 B) VirtualDOM library for creating User Interfaces\n      The .dom (\u0026ldquo;dot dom\u0026rdquo;) is the worlds smallest, most feature-packed Virtual DOM template library. This makes it ideal for embedded UIs, browser extensions, or wherever saving a single byte actually matters!\nIn just 512 bytes (compressed) it provides:\n Virtual DOM reconciliation Declarative composition using native js accelerators Stateful Components, including higher-order component composition Component Life-Cycle methods (mount, unmount, update) Keyed Updates and high-performance optimization JSX integration compatibility  "},{"idx":17,"href":"/dot-dom/categories/","title":"Categories","content":""},{"idx":18,"href":"/dot-dom/docs/","title":"Docs","content":""},{"idx":19,"href":"/dot-dom/tags/","title":"Tags","content":""}];window.bookSearch={pages:pages,idx:lunr(function(){this.ref("idx");this.field("title");this.field("content");pages.forEach(this.add,this);}),}})();