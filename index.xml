<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>.dom Documentation</title><link>https://wavesoft.github.io/dot-dom/</link><description>Recent content on .dom Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://wavesoft.github.io/dot-dom/index.xml" rel="self" type="application/rss+xml"/><item><title>Getting Started</title><link>https://wavesoft.github.io/dot-dom/docs/install/getting-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/install/getting-started/</guid><description> Getting Started Welcome to the exciting world of .dom.
There are various ways you can experiment or integrate .dom in your use case.
You can use the on-line playground You can integrate .dom in your website You can create a web-app with it Or you can keep reading to learn more about it.
Next Topic Adding .dom in your website &amp;rarr;</description></item><item><title>Globals</title><link>https://wavesoft.github.io/dot-dom/docs/api/globals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/api/globals/</guid><description>Globals When sourced, .dom library exposes a few entry point functions for defining and rendering elements.
.H - Create Element H( &amp;#39;tag&amp;#39; ) H( &amp;#39;tag&amp;#39;, {prop: &amp;#34;value&amp;#34;}) H( &amp;#39;tag&amp;#39;, H( &amp;#39;child&amp;#39; )) H( &amp;#39;tag&amp;#39;, {prop: &amp;#34;value&amp;#34;}, H( &amp;#39;child&amp;#39; )) H( Component, {prop: &amp;#34;value&amp;#34;} ) Create and return a new VDom element of the given type. The type argument can be either a tag name string (such as &amp;lsquo;div&amp;rsquo; or &amp;lsquo;span&amp;rsquo;) or a Component function.</description></item><item><title>Quick Start</title><link>https://wavesoft.github.io/dot-dom/docs/topics/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/quick-start/</guid><description> Quick Start The smallest .dom example looks like this:
R( H(&amp;#34;p&amp;#34;, &amp;#34;Hello World&amp;#34;), document.body ); It displays a paragraph, saying &amp;ldquo;Hello World&amp;rdquo; in the page, using the Declarative DOM Composition syntax.
Feel free to make some changes, and see how they affect the output. Alternatively, you can click the link below to open an online editor:
Try it in CodePen
Next Topic Declarative DOM &amp;rarr;</description></item><item><title>Adding .dom in your website</title><link>https://wavesoft.github.io/dot-dom/docs/install/add-to-website/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/install/add-to-website/</guid><description>Adding .dom in your website Use it according to your needs.
The .dom library is quite agile and can be used either in existing websites, where you just want to add some interactivity, or in a modern single-page app.
Boilerplate If you want to start from scratch, you can use the following HTML boilerplate:
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;My .dom App&amp;lt;/title&amp;gt; &amp;lt;!-- The .dom library sources --&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.</description></item><item><title>Component Functions</title><link>https://wavesoft.github.io/dot-dom/docs/api/component-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/api/component-functions/</guid><description>Component Functions This page explains in detail the component functions.
Every component function is called during the rendering phase of the DOM and it must return a valid VDom element to render. Any code logic that should be called during a particular lifecycle event of the node should be registered via the hooks object.
function Component(props, state, setState, hooks) { return ... } props : The properties object, as given by the user in the H function state : An object that contains the state values of the object setState : A function that can be used to update the state and re-render the element hooks : An object where you can register the lifecycle method hooks Note that the state object instance remains untouched throughout the life-cycle of the component.</description></item><item><title>Declarative DOM</title><link>https://wavesoft.github.io/dot-dom/docs/topics/declarative/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/declarative/</guid><description>Declarative DOM Composition The .dom library comes with a built-in accelerators that makes it possible to rapidly design human-readable DOM layouts without the need of JSX, or any other Javascript preprocessor.
This is achieved through Proxy methods built on top of the .H (create element) function, creating a native Javascript syntactic sugar:
div( div.underline( &amp;#34;Welcome!&amp;#34; ), p( &amp;#34;In this example we demonstrate &amp;#34;, &amp;#34;the &amp;#34;, b(&amp;#34;.dom&amp;#34;), &amp;#34; accelerators.&amp;#34; ), p( &amp;#34;Create &amp;#34;, span.</description></item><item><title>Creating a WebApp</title><link>https://wavesoft.github.io/dot-dom/docs/install/create-web-app/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/install/create-web-app/</guid><description>Creating a WebApp Since .dom natively supports JSX integration you can use a similar tooling like React to create a single-page application.
In this page we are describing step-by-step the process you should follow in order to create a single-page application using webpack and babel.
Starting a node project First we should start by creating a blank new node.js project:
mkdir my-dotdom-app; cd my-dotdom-app yarn init -y Setting-up Dependencies We are going to use webpack as our main build tool.</description></item><item><title>Components</title><link>https://wavesoft.github.io/dot-dom/docs/topics/components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/components/</guid><description>Components Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.
Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called &amp;ldquo;props&amp;rdquo;) and return Virtual DOM elements describing what should appear on the screen.
Component Functions All components in .dom are Javascript functions:
const { div } = H; function Welcome(props) { return div(`Hello ${props.name}`); } This function is a valid .</description></item><item><title>Stateful Components</title><link>https://wavesoft.github.io/dot-dom/docs/topics/stateful-components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/stateful-components/</guid><description>Stateful Components Components can only carry properties given, but can also maintain their own state.
For example, consider the case of a spinner widget, where the user has two buttons : one to increment the value and one to decrement, like so:
const { div, button } = H; function Spinner(props) { return div.rowflex( button(&amp;#34;-&amp;#34;), div(`${props.value}`), button(&amp;#34;&amp;#43;&amp;#34;) ); } R(H(Spinner, {value: 0}), document.body); But what should happen when the user clicks the &amp;ldquo;+&amp;rdquo; or the &amp;ldquo;-&amp;rdquo; button?</description></item><item><title>Component Lifecycle</title><link>https://wavesoft.github.io/dot-dom/docs/topics/component-lifecycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/component-lifecycle/</guid><description>Component Lifecycle Every .dom component undergoes through a three phases during it&amp;rsquo;s life-cycle : Mounted, Updated and Unmounted
As a developer, you can react to these life-cycle events in order to implement your logic.
Component Hooks You can register callback handlers to either of the three life-cycle events through the hooks object, that is given as a 4th argument to the Component function:
function Component(props, state, setState, hooks) { // .</description></item><item><title>Raw Components</title><link>https://wavesoft.github.io/dot-dom/docs/topics/raw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/raw/</guid><description>Raw Components If you are controlling the created HTML DOM instance yourself, you can mark the node as raw to disable deeper reconciliation.
By default, on every update, .dom will reconcile the children of each VNode instance. This will destroy any previous modifications to the DOM. To disable this functionality, set hooks.r to a truthy value (eg. 1 or true):
const RawComponent = (props, state, setState, hooks) =&amp;gt; { // Mark the component as raw hooks.</description></item><item><title>Keyed Updates</title><link>https://wavesoft.github.io/dot-dom/docs/topics/keyed-updates/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/keyed-updates/</guid><description> Keyed Updates When reconciling the children of a Virtual Node, .dom is using string keys to resolve their order.
Previous Topic &amp;larr; Raw Components</description></item><item><title>Serving GZ version of .dom</title><link>https://wavesoft.github.io/dot-dom/docs/install/serving-compressed/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/install/serving-compressed/</guid><description>Serving the compressed version of .dom If you want to serve .dom on it&amp;rsquo;s smallest possible size, you might want to serve it compressed.
For example, in embedded (eg. IoT) projects the device memory is quite limited. Therefore storing the uncompressed version of the library might not be desired. In such cases, you can always serve .dom directly on it&amp;rsquo;s compressed form.
This is achieved simply by setting the correct encoding response header while streaming the compressed library to the client:</description></item></channel></rss>