<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>.dom Documentation</title><link>https://wavesoft.github.io/dot-dom/</link><description>Recent content on .dom Documentation</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://wavesoft.github.io/dot-dom/index.xml" rel="self" type="application/rss+xml"/><item><title>Getting Started</title><link>https://wavesoft.github.io/dot-dom/docs/install/getting-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/install/getting-started/</guid><description> Getting Started Welcome to the exciting world of .dom.
There are various ways you can experiment or integrate .dom in your use case.
You can use the on-line playground You can integrate .dom in your website You can create a web-app with it Or you can keep reading to learn more about it.
Next Topic Adding .dom in your website &amp;rarr;</description></item><item><title>Globals</title><link>https://wavesoft.github.io/dot-dom/docs/api/globals/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/api/globals/</guid><description>Globals When sourced, .dom library exposes a few entry point functions for defining and rendering elements.
.H - Create Element H( &amp;#39;tag&amp;#39; ) H( &amp;#39;tag&amp;#39;, {prop: &amp;#34;value&amp;#34;}) H( &amp;#39;tag&amp;#39;, H( &amp;#39;child&amp;#39; )) H( &amp;#39;tag&amp;#39;, {prop: &amp;#34;value&amp;#34;}, H( &amp;#39;child&amp;#39; )) H( Component, {prop: &amp;#34;value&amp;#34;} ) Create and return a new VDom element of the given type. The type argument can be either a tag name string (such as &amp;lsquo;div&amp;rsquo; or &amp;lsquo;span&amp;rsquo;) or a Component function.</description></item><item><title>Quick Start</title><link>https://wavesoft.github.io/dot-dom/docs/topics/quick-start/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/quick-start/</guid><description> Quick Start The smallest .dom example looks like this:
UigKICBIKCYjMzQ7cCYjMzQ7LCAmIzM0O0hlbGxvIFdvcmxkJiMzNDspLAogIGRvY3VtZW50LmJvZHkKKTs= Loading interactive example... It displays a paragraph, saying &amp;ldquo;Hello World&amp;rdquo; in the page, using the Declarative DOM Composition syntax.
Feel free to make some changes, and see how they affect the output. Alternatively, you can click the link below to open an online editor:
Try it in CodePen
Next Topic Declarative DOM &amp;rarr;</description></item><item><title>Adding .dom in your website</title><link>https://wavesoft.github.io/dot-dom/docs/install/add-to-website/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/install/add-to-website/</guid><description>Adding .dom in your website Use it according to your needs.
The .dom library is quite agile and can be used either in existing websites, where you just want to add some interactivity, or in a modern single-page app.
Boilerplate If you want to start from scratch, you can use the following HTML boilerplate:
&amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;My .dom App&amp;lt;/title&amp;gt; &amp;lt;!-- The .dom library sources --&amp;gt; &amp;lt;script src=&amp;#34;https://cdn.</description></item><item><title>Component Functions</title><link>https://wavesoft.github.io/dot-dom/docs/api/component-functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/api/component-functions/</guid><description>Component Functions This page explains in detail the component functions.
Every component function is called during the rendering phase of the DOM and it must return a valid VDom element to render. Any code logic that should be called during a particular lifecycle event of the node should be registered via the hooks object.
function Component(props, state, setState, hooks) { return ... } props : The properties object, as given by the user in the H function state : An object that contains the state values of the object setState : A function that can be used to update the state and re-render the element hooks : An object where you can register the lifecycle method hooks Note that the state object instance remains untouched throughout the life-cycle of the component.</description></item><item><title>Declarative DOM</title><link>https://wavesoft.github.io/dot-dom/docs/topics/declarative/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/declarative/</guid><description>Declarative DOM Composition The .dom library comes with a built-in accelerators that makes it possible to rapidly design human-readable DOM layouts without the need of JSX, or any other Javascript preprocessor.
This is achieved through Proxy methods built on top of the .H (create element) function, creating a native Javascript syntactic sugar:
ZGl2KAogIGRpdi51bmRlcmxpbmUoCiAgICAmIzM0O1dlbGNvbWUhJiMzNDsKICApLAogIHAoCiAgICAmIzM0O0luIHRoaXMgZXhhbXBsZSB3ZSBkZW1vbnN0cmF0ZSAmIzM0OywKICAgICYjMzQ7dGhlICYjMzQ7LCBiKCYjMzQ7LmRvbSYjMzQ7KSwgJiMzNDsgYWNjZWxlcmF0b3JzLiYjMzQ7CiAgKSwKICBwKAogICAgJiMzNDtDcmVhdGUgJiMzNDssIHNwYW4ucmVkKCYjMzQ7cG93ZXJmdWwmIzM0OyksCiAgICAmIzM0OyBsYXlvdXRzIHdpdGggJiMzNDssIGIoJiMzNDtuYXRpdmUgSlMhJiMzNDspCiAgKQop Loading interactive example... .tag Accelerators When accessing a property out of the H function, a new function is composed, with the tag argument, bound to a tag named as the property.</description></item><item><title>Creating a WebApp</title><link>https://wavesoft.github.io/dot-dom/docs/install/create-web-app/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/install/create-web-app/</guid><description>Creating a WebApp Since .dom natively supports JSX integration you can use a similar tooling like React to create a single-page application.
In this page we are describing step-by-step the process you should follow in order to create a single-page application using webpack and babel.
Starting a node project First we should start by creating a blank new node.js project:
mkdir my-dotdom-app; cd my-dotdom-app yarn init -y Setting-up Dependencies We are going to use webpack as our main build tool.</description></item><item><title>VDom Element</title><link>https://wavesoft.github.io/dot-dom/docs/api/vdom-element/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/api/vdom-element/</guid><description>VDom Element A Virtual DOM (VDom) element is created with the H() method and represents the shadow of a real DOM Element.
VDom Types A VDom instance can be one of the following types:
Object - Represents an HTML element, identified by a tag, attributes and children. String - Represents a #text node, that only carries it&amp;rsquo;s contents Note that the H() function only creates Object VDom instances.</description></item><item><title>Components</title><link>https://wavesoft.github.io/dot-dom/docs/topics/components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/components/</guid><description>Components Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.
Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called &amp;ldquo;props&amp;rdquo;) and return Virtual DOM elements describing what should appear on the screen.
Component Functions All components in .dom are Javascript functions:
const { div } = H; function Welcome(props) { return div(`Hello ${props.name}`); } This function is a valid .</description></item><item><title>Stateful Components</title><link>https://wavesoft.github.io/dot-dom/docs/topics/stateful-components/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/stateful-components/</guid><description>Stateful Components Components can only carry properties given, but can also maintain their own state.
For example, consider the case of a spinner widget, where the user has two buttons : one to increment the value and one to decrement, like so:
Y29uc3QgeyBkaXYsIGJ1dHRvbiB9ID0gSDsKCmZ1bmN0aW9uIFNwaW5uZXIocHJvcHMpIHsKICByZXR1cm4gZGl2LnJvd2ZsZXgoCiAgICBidXR0b24oJiMzNDstJiMzNDspLAogICAgZGl2KGAke3Byb3BzLnZhbHVlfWApLAogICAgYnV0dG9uKCYjMzQ7KyYjMzQ7KQogICk7Cn0KClIoSChTcGlubmVyLCB7dmFsdWU6IDB9KSwgZG9jdW1lbnQuYm9keSk7 Loading interactive example... But what should happen when the user clicks the &amp;ldquo;+&amp;rdquo; or the &amp;ldquo;-&amp;rdquo; button? To answer this question we will introduce you to the Component State</description></item><item><title>Component Lifecycle</title><link>https://wavesoft.github.io/dot-dom/docs/topics/component-lifecycle/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/component-lifecycle/</guid><description>Component Lifecycle Every .dom component undergoes through a three phases during it&amp;rsquo;s life-cycle : Mounted, Updated and Unmounted
As a developer, you can react to these life-cycle events in order to implement your logic.
Component Hooks You can register callback handlers to either of the three life-cycle events through the hooks object, that is given as a 4th argument to the Component function:
function Component(props, state, setState, hooks) { // .</description></item><item><title>Raw Components</title><link>https://wavesoft.github.io/dot-dom/docs/topics/raw/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/raw/</guid><description>Raw Components If you are controlling the created HTML DOM instance yourself, you can mark the node as raw to disable deeper reconciliation.
By default, on every update, .dom will reconcile the children of each VNode instance. This will destroy any previous modifications to the DOM. To disable this functionality, set hooks.r to a truthy value (eg. 1 or true):
const RawComponent = (props, state, setState, hooks) =&amp;gt; { // Mark the component as raw hooks.</description></item><item><title>Reconciliation</title><link>https://wavesoft.github.io/dot-dom/docs/topics/reconciliation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/reconciliation/</guid><description>Reconciliation Because of it&amp;rsquo;s declarative nature, .dom knows which elements to update on a reconciliation events, so there is no requirement by the developer to explicitly control this process.
In this document we are describing the details of the reconciliation process of the library, since there are some specific cases where the developer should pay attention. Especially when designing performance-critical interfaces.
Reconciliation in .dom First and foremost is important to clarify that .</description></item><item><title>Serving GZ version of .dom</title><link>https://wavesoft.github.io/dot-dom/docs/install/serving-compressed/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/install/serving-compressed/</guid><description>Serving the compressed version of .dom If you want to serve .dom on it&amp;rsquo;s smallest possible size, you might want to serve it compressed.
For example, in embedded (eg. IoT) projects the device memory is quite limited. Therefore storing the uncompressed version of the library might not be desired. In such cases, you can always serve .dom directly on it&amp;rsquo;s compressed form.
This is achieved simply by setting the correct encoding response header while streaming the compressed library to the client:</description></item><item><title>Gotchas</title><link>https://wavesoft.github.io/dot-dom/docs/topics/gotchas/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://wavesoft.github.io/dot-dom/docs/topics/gotchas/</guid><description>Gotchas Since .dom is optimized for size and not for performance nor developer friendliness, you should be aware that there are few rough edges.
Component roots cannot change The component state is preserved on it&amp;rsquo;s root DOM element. On it&amp;rsquo;s own turn, this element is indexed by the component&amp;rsquo;s key.
This means, that once mounted, the component won&amp;rsquo;t be able to change the type of the root element, since it will be persisted in the cache.</description></item></channel></rss>